<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="月夜静翼"><meta name="renderer" content="webkit"><meta name="copyright" content="月夜静翼"><meta name="keywords" content="月夜静翼的天文台"><meta name="description" content=""><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>月夜静翼的天文台</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 5.4.2"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/default-avatar.jpg"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">月夜静翼</div><div class="profile-signature">随笔录</div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">月夜静翼的天文台</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1>月夜静翼的天文台</h1><h5>Welcome to my Blog!</h5><div class="intro-social"><a class="fa fa-envelope" href="mailto:2248664811@qq.com" title="email"></a><a class="fa fa-github" href="https://github.com/xiuya19" target="_blank" title="github"></a></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><section id="recent-posts"><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">vue3源码解析</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:19:57.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:19:57.000Z">2023-01-31</time></div><div class="recent-post-content">虚拟dom以javascript对象表示为document对象
虚拟dom的优势目前框架都会引入虚拟DOM来对真实的DOM进行抽象，这样做有很多的好处
首先是可以对真实的元素节点进行抽象，抽象成VNode（虚拟节点），这样方便后续对其进行各种操作

因为对于直接操作DOM来说是有很多的限制的，比如diff、clone等等，但是使用JavaScript编程语言来操作这些，就变得非常的简单
我们可以使用JavaScript来表达非常多的逻辑，而对于DOM本身来说是非常不方便的

其次是方便实现跨平台，包括你可以将VNode节点渲染成任意你想要的节点

如渲染在canvas、WebGL、SSR、Na ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="vue"> vue</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="源码"> 源码</a></div><div class="read-more"><a class="more" href="/2023/01/31/vue3%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89/">垃圾回收机制（GC）</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:20:57.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:20:57.000Z">2023-01-31</time></div><div class="recent-post-content">垃圾回收机制（GC）垃圾回收（Garbage Collection，缩写为GC）是一种自动的存储器管理机制。当某个程序占用的一部分内存空间不再被这个程序访问时，这个程序会借助垃圾回收算法向操作系统归还这部分内存空间。垃圾回收器可以减轻程序员的负担，也减少程序中的错误。垃圾回收最早起源于LISP语言。目前许多语言如Smalltalk、Java、C#和D语言都支持垃圾回收器，我们熟知的 JavaScript 具有自动垃圾回收机制。 
垃圾回收语言通过周期性地检查先前分配的内存是否可达，帮助开发者管理内存。换言之，垃圾回收语言减轻了“内存仍可用”及“内存仍可达”的问题。两者的区别是微妙而重要的：仅有 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="浏览器"> 浏览器</a></div><div class="read-more"><a class="more" href="/2023/01/31/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/%E8%B7%A8%E5%9F%9F/">跨域</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:20:44.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:20:44.000Z">2023-01-31</time></div><div class="recent-post-content">什么是跨域出于浏览器的同源策略限制。
同源策略同源策略(Sameoriginpolicy)是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。
可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。
同源策略会阻止一个域的javascript脚本和另外一个域的内容进行交互。所谓同源(即指在同一个域)就是两个页面具有相同的协议(protocol)，主机(host)和端口号(port)
什么情况下会跨域 当一个请求url的协议、域名、端口三者之间任意一个与当前页面url不同即为跨域 



当前页面url
请求url
是否跨域 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="javascript"> javascript</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="浏览器"> 浏览器</a></div><div class="read-more"><a class="more" href="/2023/01/31/%E8%B7%A8%E5%9F%9F/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/vue-router/">vue-router</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:20:03.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:20:03.000Z">2023-01-31</time></div><div class="recent-post-content">浏览器与路由路由的概念在软件工程中出现，最早是在后端路由中实现的，原因是web的发展主要经历了这样一些阶段

后端路由阶段
前后端分离阶段
单页面富应用（SPA）

URL的hash前端路由是如何做到URL和内容进行映射呢？监听URL的改变。
URL的hash

URL的hash也就是锚点(#), 本质上是改变window.location的href属性
我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新

hash的优势就是兼容性更好，在老版IE中都可以运行，但是缺陷是有一个#，显得不像一个真实的路径
12345678910111213141516171819 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="vue"> vue</a><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="router"> router</a></div><div class="read-more"><a class="more" href="/2023/01/31/vue-router/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">事件循环</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:21:58.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:21:58.000Z">2023-01-31</time></div><div class="recent-post-content">JS引擎本文不详细解释浏览器线程，只着重说明任务队列的执行
JavaScript 是一门单线程语言，虽然在 html5 中提出了 Web-Worker ，但这并未改变 JavaScript 是单线程这一核心。
浏览器是多进程的，其中和前端关系最紧密的是浏览器渲染进程（也称浏览器内核），其中包括GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等。
在JS引擎中有一个main thread 主进程和call-stack（一个调用堆栈），在对一个调用堆栈中的task处理的时候，其他的都要等着。当在执行过程中遇 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="javascript"> javascript</a></div><div class="read-more"><a class="more" href="/2023/01/31/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/vuex/">vuex</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:20:19.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:20:19.000Z">2023-01-31</time></div><div class="recent-post-content">状态管理什么是状态管理在开发中，我们会的应用程序需要处理各种各样的数据，这些数据需要保存在我们应用程序中的某一个位置，对于这些数据的管理我们就称之为是 状态管理。
在Vue开发中，我们使用组件化的开发方式而在组件中我们定义data或者在setup中返回使用的数据，这些数据我们称之为state在模块template中我们可以使用这些数据，模块最终会被渲染成DOM，我们称之为View在模块中我们会产生一些行为事件，处理这些行为事件时，有可能会修改state，这些行为事件我们称之为actions
复杂的状态管理JavaScript开发的应用程序，已经变得越来越复杂了：

JavaScript需要管理 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="vue"> vue</a></div><div class="read-more"><a class="more" href="/2023/01/31/vuex/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/%E9%89%B4%E6%9D%83%E5%92%8C%E5%9C%A8node%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/">鉴权和在node上的实现</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:21:36.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:21:36.000Z">2023-01-31</time></div><div class="recent-post-content">鉴权目前常见的鉴权方式有4种

session-cookie
token(jwt)
OAuth(开放授权)
SSO

session-cookiesession会话机制是⼀种服务器端机制，它使⽤类似于哈希表（可能还有哈希表）的结构来保存信息。
实现原理
服务器在接受客户端⾸次访问时在服务器端创建seesion，然后保存seesion(我们可以将seesion保存在内存中，也可以保存在redis中，推荐使⽤后者)，然后给这个session⽣成⼀个唯⼀的标识字符串,然后在响应头中种下这个唯⼀标识字符串。
签名。这⼀步通过秘钥对sid进⾏签名处理，避免客户端修改sid。（⾮必需步骤）
浏览器中收到请 ...</div><div class="read-more"><a class="more" href="/2023/01/31/%E9%89%B4%E6%9D%83%E5%92%8C%E5%9C%A8node%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/js%E4%B8%AD%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/">js中属性描述符与对象状态</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:22:09.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:22:09.000Z">2023-01-31</time></div><div class="recent-post-content">属性描述符对象属性描述符的类型分为两种: 数据属性和访问器属性。
数据属性数据属性(data property)包含一个数据值的位置，在这个位置可以读取和写入值。数据属性有4个特性

Configurable(可配置性): 可配置性决定是否可以delete删除属性，以及是否可以修改属性描述符的特性(Object.defineProperty)，默认值为true。

Enumerable(可枚举性): 可枚举性决定属性是否出现在对象的属性枚举中，比如是否可以通过for-in循环返回该属性，默认值为true。

Writable(可写性): 可写性决定是否可以修改属性的值，默认值为true。 设置 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="javascript"> javascript</a></div><div class="read-more"><a class="more" href="/2023/01/31/js%E4%B8%AD%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/js%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">js中的基本数据类型</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:20:30.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:20:30.000Z">2023-01-31</time></div><div class="recent-post-content">变量的声明目前定义变量可以使用三种关键字：var / let / const



变量
变量提升
暂时死区
重复声明
初始值
作用域
类型



var
会
不存在
可重复声明
非必需
函数级
变量


let
不会
存在
不可重复声明
非必需
块级
变量


const
不会
存在
不可重复声明
必须
块级
常量


const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，**const只 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="javascript"> javascript</a></div><div class="read-more"><a class="more" href="/2023/01/31/js%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#more">ReadMore</a></div><hr></div><div class="recent-post-item"><div class="post-title"><a href="/2023/01/31/js%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/">js中的浅拷贝与深拷贝</a></div><div class="post-time"><i class="fa fa-table"></i><time datetime="2023-01-31T03:21:50.000Z">2023-01-31</time><i class="fa fa-edit"></i><time datetime="2023-01-31T03:21:50.000Z">2023-01-31</time></div><div class="recent-post-content">数据类型数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。

基本数据类型的特点：直接存储在栈(stack)中的数据

引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里


引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。
浅拷贝与深拷贝概念浅拷贝：新的对象复制已有对象中非对象属性的值和对象属性的引用。也可以理解为：一个新的对象直接拷贝已存在的对象的对象属性的引用，即浅拷贝。
深拷贝： 复制变量值，对于 ...</div><div class="recent-post-tags"><a class="post-tag fa fa-tag" href="javascript:void(0)" date-tags="javascript"> javascript</a></div><div class="read-more"><a class="more" href="/2023/01/31/js%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/#more">ReadMore</a></div><hr></div></section><nav class="cxo-page-nav"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">NEXT &amp;#62;</a></nav></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>