<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>月夜静翼的天文台</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="月夜静翼的天文台">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="月夜静翼的天文台">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="月夜静翼">
<meta property="article:tag" content="前端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="月夜静翼的天文台" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">月夜静翼的天文台</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-this指针" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/this%E6%8C%87%E9%92%88/" class="article-date">
  <time datetime="2023-01-31T03:19:47.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/this%E6%8C%87%E9%92%88/">this指针</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="this指针含义"><a href="#this指针含义" class="headerlink" title="this指针含义"></a>this指针含义</h1><p>代码都在这里<a target="_blank" rel="noopener" href="https://gitee.com/xiuya19/study-project/tree/master/test-html">https://gitee.com/xiuya19/study-project/tree/master/test-html</a></p>
<h2 id="this指针是什么"><a href="#this指针是什么" class="headerlink" title="this指针是什么"></a>this指针是什么</h2><p>在常见的编程语言中，几乎都有this这个关键字(Objective-C中使用的是self)，但是JavaScript中的this和常见的面向对象语言中的this不太一样：</p>
<ul>
<li>常见面向对象的编程语言中，比如Java、C++、Swift、Dart等等一系列语言中，this通常只会出现在类的方法中</li>
<li>也就是你需要有一个类，类中的方法(特别是实例方法)中，this代表的是当前调用对象</li>
<li>但是JavaScript中的this更加灵活，无论是它出现的位置还是它代表的含义</li>
<li><code>this</code> 的值是在 <strong>「代码运行时计算出来」</strong> 的，它的值取决于代码上下文</li>
</ul>
<h2 id="为什么要使用this指针"><a href="#为什么要使用this指针" class="headerlink" title="为什么要使用this指针"></a>为什么要使用this指针</h2><p>当对象方法需要使用对象中的属性，可以使用 <code>this</code> 关键字<br>如果没有this，那么我们的代码会是下面的写法(注释部分的写法)：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">running</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(obj.name + &quot; running&quot;);</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; running&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">eating</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(obj.name + &quot; eating&quot;);</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; eating&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">studying</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(obj.name + &quot; studying&quot;);</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; studying&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在上述方法中的注释部分，为了能够获取到name名称，必须通过obj的引用(变量名称)来获取</li>
<li>但是这样做有一个很大的弊端：如果我将obj的名称换成了info，那么所有的方法中的obj都需要换成info</li>
</ul>
<p>我们会发现，在某些函数或者方法的编写中，this可以让我们更加便捷的方式来引用对象，在进行一些API设计时，代码更加的简洁和易于复用<br>当然，上面只是应用this的一个场景而已，开发中使用到this的场景到处都是，这也是为什么它不容易理解的原因</p>
<h1 id="this指针绑定规则"><a href="#this指针绑定规则" class="headerlink" title="this指针绑定规则"></a>this指针绑定规则</h1><p>在ES6箭头函数之前，可以用一句简单的话来概括就是：<strong>谁调用它，this 就指向谁</strong><br>然而也存在一些特殊的规则使得上面那句话不太准确因此我们需要借助一些规则去帮助自己</p>
<p>绑定规则主要分为：默认绑定、隐式绑定、显式绑定、new绑定等<br>另外还包含其他方式的绑定：如ES6箭头函数的绑定等</p>
<h2 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h2><p>默认绑定，<strong>在不能应用其它绑定规则时使用的默认规则</strong>，通常是独立函数调用</p>
<ul>
<li>其中独立函数我们可以理解成函数没有被绑定到某个对象上进行调用</li>
<li>非严格模式：node 环境，执行全局对象 global，浏览器环境，执行全局对象 window</li>
<li>严格模式：执行 undefined</li>
</ul>
<h3 id="case-1-普通函数调用"><a href="#case-1-普通函数调用" class="headerlink" title="case 1 普通函数调用"></a>case 1 普通函数调用</h3><ul>
<li>该函数直接被调用，并没有进行任何的对象关联</li>
<li>这种独立的函数调用会使用默认绑定，通常默认绑定时，函数中的this指向全局对象(浏览器中为window, node环境中为global)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h3 id="case-2-函数调用链-一个函数又调用另外一个函数"><a href="#case-2-函数调用链-一个函数又调用另外一个函数" class="headerlink" title="case 2 函数调用链(一个函数又调用另外一个函数)"></a>case 2 函数调用链(一个函数又调用另外一个函数)</h3><p>所有的函数调用都没有被绑定到某个对象上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">  <span class="title function_">test2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">  <span class="title function_">test3</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test1</span>()</span><br></pre></td></tr></table></figure>

<h3 id="case3-将函数作为参数，传入到另一个函数中"><a href="#case3-将函数作为参数，传入到另一个函数中" class="headerlink" title="case3 将函数作为参数，传入到另一个函数中"></a>case3 将函数作为参数，传入到另一个函数中</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(bar)</span><br></pre></td></tr></table></figure>

<h3 id="case-4-将一个对象的属性函数作为参数，传入到另一个函数中"><a href="#case-4-将一个对象的属性函数作为参数，传入到另一个函数中" class="headerlink" title="case 4 将一个对象的属性函数作为参数，传入到另一个函数中"></a>case 4 将一个对象的属性函数作为参数，传入到另一个函数中</h3><p>在真正函数调用的位置，并没有进行任何的对象绑定，只是一个独立函数的调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">func</span>) &#123;</span><br><span class="line">  <span class="title function_">func</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(obj.<span class="property">bar</span>)</span><br></pre></td></tr></table></figure>

<h2 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h2><p>隐式绑定，调用方式是通过某个对象进行调用的 ，即调用位置上存在上下文对象</p>
<ul>
<li>它的调用位置中，是通过某个对象发起的函数调用 </li>
<li>典型的隐式调用为: <code>xxx.fn()</code></li>
</ul>
<h3 id="case1-通过对象调用函数"><a href="#case1-通过对象调用函数" class="headerlink" title="case1 通过对象调用函数"></a>case1 通过对象调用函数</h3><p>foo的调用位置是obj.foo()方式进行调用的, 那么foo调用时this会隐式的被绑定到obj对象上</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// obj1对象 &#123;name: &#x27;why&#x27;, foo: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="case2-case1变种"><a href="#case2-case1变种" class="headerlink" title="case2 case1变种"></a>case2 case1变种</h3><p>我们通过obj2又引用了obj1对象，再通过obj1对象调用foo函数<br>那么foo调用的位置上其实还是obj1被绑定了this(可以理解为最近调用的对象)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// obj1对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>,</span><br><span class="line">  <span class="attr">obj1</span>: obj1</span><br><span class="line">&#125;</span><br><span class="line">obj2.<span class="property">obj1</span>.<span class="title function_">foo</span>() <span class="comment">// obj1对象 &#123;name: &#x27;why&#x27;, foo: ƒ&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="case3-隐式丢失"><a href="#case3-隐式丢失" class="headerlink" title="case3 隐式丢失"></a>case3 隐式丢失</h3><p>结果最终是window, 因为foo最终被调用的位置是bar，而bar在进行调用时没有绑定任何的对象，也就没有形成隐式绑定<br>可以理解为一种默认绑定</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 讲obj1的foo赋值给bar</span></span><br><span class="line"><span class="keyword">var</span> bar = obj1.<span class="property">foo</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<h2 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h2><p>隐式绑定有一个前提条件：</p>
<ul>
<li>必须在调用的<strong>对象内部</strong>有一个对函数的引用（比如一个属性）</li>
<li>如果没有这样的引用，在进行调用时，会报找不到该函数的错误</li>
<li>正是通过这个引用，间接的将this绑定到了这个对象上</li>
</ul>
<p>如果我们不希望在<strong>对象内部</strong>包含这个函数的引用，同时又希望在这个对象上进行强制调用，该怎么做呢？</p>
<ul>
<li>JavaScript所有的函数都可以使用call,apply方法<ul>
<li>两个的区别，第一个参数是相同的，后面的参数，apply为数组，call为参数列表</li>
<li>两者都会立即执行</li>
</ul>
</li>
<li>这两个函数的第一个参数都要求是一个对象，这个对象的作用是什么呢？就是给this准备的<ul>
<li><code>function.call(thisArg, arg1, arg2, ...)</code></li>
<li><code>function.apply(thisArg, [argsArray])</code></li>
</ul>
</li>
<li>此外还有一个bind方法，与call,apply立即执行不同，返回一个原函数的拷贝，并拥有指定的 this 值和初始参数<ul>
<li><code>function.bind(thisArg, arg1, arg2, ...)</code></li>
</ul>
</li>
<li>用这个函数时，会将this绑定到这个传入的对象上</li>
</ul>
<p>上面的过程，我们明确的绑定了this指向的对象，所以称之为<strong>显示绑定</strong></p>
<h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call,apply"></a>call,apply</h3><p>通过call或者apply绑定this对象，显示绑定后，this就会明确的指向绑定的对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">call</span>(<span class="variable language_">window</span>); <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">call</span>(&#123;<span class="attr">name</span>: <span class="string">&quot;why&quot;</span>&#125;); <span class="comment">// &#123;name: &quot;why&quot;&#125;</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="number">123</span>); <span class="comment">// Number对象,存放时123</span></span><br></pre></td></tr></table></figure>

<h3 id="bind和this持久绑定"><a href="#bind和this持久绑定" class="headerlink" title="bind和this持久绑定"></a>bind和this持久绑定</h3><p>如果我们希望一个函数总是显示的绑定到一个对象上，可以用以下三种方法</p>
<ol>
<li>手写辅助函数（实际上是模仿bind）</li>
<li>使用Function.prototype.bind</li>
<li>内置函数</li>
</ol>
<h4 id="bind绑定"><a href="#bind绑定" class="headerlink" title="bind绑定"></a>bind绑定</h4><p>bind方法返回一个原函数的拷贝，并拥有指定的 this 值和初始参数，即返回值为我们所需要的持久显示绑定函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj)</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// obj对象 &#123;name: &#x27;why&#x27;&#125;</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// obj对象 &#123;name: &#x27;why&#x27;&#125;</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// obj对象 &#123;name: &#x27;why&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="内置函数绑定"><a href="#内置函数绑定" class="headerlink" title="内置函数绑定"></a>内置函数绑定</h4><p>有些时候，我们会调用一些JavaScript的内置函数，或者一些第三方库中的内置函数</p>
<ul>
<li>这些内置函数会要求我们传入另外一个函数</li>
<li>我们自己并不会显示的调用这些函数，而且JavaScript内部或者第三方库内部会帮助我们执行</li>
</ul>
<p>传入到内置函数的回调函数this确定方法</p>
<ul>
<li>某些内置的函数，我们很难确定它内部是如何调用传入的回调函数</li>
<li>一方面可以通过分析源码来确定，另一方面我们可以通过经验（见多识广）来确定</li>
<li><strong>但是无论如何，通常都是我们之前讲过的规则来确定的</strong></li>
</ul>
<p>常见案例如下：</p>
<h5 id="case1-setTimeout"><a href="#case1-setTimeout" class="headerlink" title="case1 setTimeout"></a>case1 setTimeout</h5><p>setTimeout中会传入一个函数(非es6箭头函数)，这个函数中的this通常是window</p>
<ul>
<li>这个和setTimeout源码的内部调用有关，setTimeout内部是通过apply进行绑定的this对象，并且绑定的是全局对象</li>
<li>如果为箭头函数时使用箭头函数绑定规则</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timer = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// &#123;foo: ƒ&#125;</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">timer.<span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h5 id="case2-数组的forEach"><a href="#case2-数组的forEach" class="headerlink" title="case2 数组的forEach"></a>case2 数组的forEach</h5><p>数组有一个高阶函数forEach，用于函数的遍历：</p>
<ul>
<li>在forEach中传入的函数打印的也是Window对象</li>
<li>这是因为默认情况下传入的函数是自动调用函数（默认绑定）</li>
<li><strong>如果需要改变this指向，就在forEach方法最后添加指向参数，这一方法只适用function定义的函数，如果forEach中的函数为箭头函数，则会优先遵循箭头函数的绑定</strong></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;cba&quot;</span>, <span class="string">&quot;nba&quot;</span>]</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">&quot;why&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 三次window</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span>(<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 三次obj对象</span></span><br><span class="line">&#125;, obj)</span><br><span class="line"></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>) <span class="comment">// 三次window</span></span><br><span class="line">&#125;, obj)</span><br></pre></td></tr></table></figure>

<h5 id="case3-div的点击"><a href="#case3-div的点击" class="headerlink" title="case3 div的点击"></a>case3 div的点击</h5><p>如果我们有一个div元素</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;-省略了部分代码-&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>获取元素节点，并且监听点击：</p>
<ul>
<li>在点击事件的回调中，box对象</li>
<li>这是因为在发生点击时，执行传入的回调函数被调用时，会将box对象绑定到该函数中</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.box&quot;</span>);</span><br><span class="line">box.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// box对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h2><p>JavaScript中的函数可以当做一个类的构造函数来使用，也就是使用new关键字</p>
<p>使用new关键字来调用函数时，会执行如下的操作</p>
<ul>
<li>创建一个空对象，并且 this 变量引用该对象</li>
<li>同时还继承了该函数的原型</li>
<li>执行构造函数方法，属性和方法被加入到 this 引用的对象中</li>
<li>如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">_new</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> target=&#123;&#125;;<span class="comment">//创建的新对象</span></span><br><span class="line">    <span class="comment">// 第一个参数是构造函数</span></span><br><span class="line">    <span class="keyword">let</span> [constructor,...args]=[...<span class="variable language_">arguments</span>];</span><br><span class="line">    <span class="comment">// 执行 [[原型]] 连接 ;target 是 constructor 的实例</span></span><br><span class="line">    target.<span class="property">__proto__</span>=constructor.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="comment">// 执行构造函数，将属性或方法添加到创建的空对象上</span></span><br><span class="line">    <span class="keyword">let</span> result=constructor.<span class="title function_">apply</span>(target,args);</span><br><span class="line">    <span class="keyword">if</span> (result &amp;&amp; (<span class="keyword">typeof</span> (result) == <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> (result) == <span class="string">&quot;function&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果构造函数执行的结构返回的是一个对象，那么返回这个对象</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果构造函数返回的不是一个对象，返回创建的新对象</span></span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="规则优先级和总结"><a href="#规则优先级和总结" class="headerlink" title="规则优先级和总结"></a>规则优先级和总结</h2><p>new绑定 &gt; 显示绑定（bind）&gt; 隐式绑定 &gt; 默认绑定</p>
<p>测试例子如下</p>
<h3 id="case1-显示绑定优先级高于隐式绑定"><a href="#case1-显示绑定优先级高于隐式绑定" class="headerlink" title="case1 显示绑定优先级高于隐式绑定"></a>case1 显示绑定优先级高于隐式绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">obj1.<span class="title function_">foo</span>() <span class="comment">// obj1</span></span><br><span class="line">obj2.<span class="title function_">foo</span>() <span class="comment">// obj2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定和显示绑定同时存在</span></span><br><span class="line">obj1.<span class="property">foo</span>.<span class="title function_">call</span>(obj2) <span class="comment">// obj2, 说明显式绑定优先级更高</span></span><br></pre></td></tr></table></figure>

<h3 id="new绑定优先级高于隐式绑定"><a href="#new绑定优先级高于隐式绑定" class="headerlink" title="new绑定优先级高于隐式绑定"></a>new绑定优先级高于隐式绑定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">foo</span>() <span class="comment">// foo对象, 说明new绑定优先级更高</span></span><br></pre></td></tr></table></figure>

<h3 id="new绑定优先级高于bind"><a href="#new绑定优先级高于bind" class="headerlink" title="new绑定优先级高于bind"></a>new绑定优先级高于bind</h3><p>new绑定和call、apply是不允许同时使用的，所以不存在谁的优先级更高</p>
<p>new绑定可以和bind后的函数同时使用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// var foo = new foo.call(obj); // 报错</span></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(obj)</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> <span class="title function_">bar</span>() <span class="comment">// 打印foo, 说明使用的是new绑定</span></span><br></pre></td></tr></table></figure>

<h1 id="绑定规则外"><a href="#绑定规则外" class="headerlink" title="绑定规则外"></a>绑定规则外</h1><p>通常来说上述规则在开发过程中足够了，不过在编码阶段经常会有各种bug和奇怪的语法，超出了我们的规则之外，下面是常见的规则外</p>
<h2 id="忽略显式绑定"><a href="#忽略显式绑定" class="headerlink" title="忽略显式绑定"></a>忽略显式绑定</h2><p>如果在显示绑定中，我们传入一个null或者undefined，那么这个显示绑定会被忽略，使用默认规则</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;why&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">call</span>(obj) <span class="comment">// obj对象</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">call</span>(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = foo.<span class="title function_">bind</span>(<span class="literal">null</span>)</span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<h2 id="间接函数引用"><a href="#间接函数引用" class="headerlink" title="间接函数引用"></a>间接函数引用</h2><p>另外一种情况，创建一个函数的<strong>间接引用</strong>，这种情况使用默认绑定规则</p>
<p>下面是举例，通过obj2简介用用obj1的foo</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj1&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: foo</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;obj2&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj1.<span class="title function_">foo</span>() <span class="comment">// obj1对象</span></span><br><span class="line">(obj2.<span class="property">foo</span> = obj1.<span class="property">foo</span>)()  <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<ul>
<li>赋值(obj2.foo = obj1.foo)的结果是foo函数</li>
<li>foo函数被直接调用，那么是默认绑定</li>
</ul>
<h2 id="ES6箭头函数"><a href="#ES6箭头函数" class="headerlink" title="ES6箭头函数"></a>ES6箭头函数</h2><p>在ES6中新增一个非常好用的函数类型：箭头函数</p>
<p>箭头函数不使用this的四种标准规则（也就是不绑定this），而是根据外层作用域来决定this。</p>
<p>我们来看一个案例：</p>
<p>objF中定义三个方法</p>
<ul>
<li>定义getData1时用function，setTimeout中也用function</li>
<li>定义getData2时用function，setTimeout中也用箭头函数</li>
<li>定义getData3时用箭头函数，setTimeout中也用箭头函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objF = &#123;</span><br><span class="line">  <span class="attr">data</span>: [],</span><br><span class="line">  <span class="attr">getData1</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通函数 this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;普通函数 _this&#x27;</span>, _this) <span class="comment">// objF</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getData2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setTimeout是箭头函数 this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// objF</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getData3</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;都是箭头函数 this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getData4</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;定义方法是箭头函数 this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">objF.<span class="title function_">getData1</span>()</span><br><span class="line">objF.<span class="title function_">getData2</span>()</span><br><span class="line">objF.<span class="title function_">getData3</span>()</span><br><span class="line">objF.<span class="title function_">getData4</span>()</span><br></pre></td></tr></table></figure>

<p>getData1中this为window，这个在显示绑定-内置函数绑定中说过，和setTimeout源码的内部调用有关，setTimeout内部是通过apply进行绑定的this对象，并且绑定的是全局对象</p>
<p>getData2中结果为objF，因为箭头函数并不绑定this对象，那么this引用就会从上层作用域中找到对应的this</p>
<p>getData3中结果为window，根据箭头函数绑定规则，会不断的从上层作用域找，那么找到了全局作用域，此时全局作用域为window(同样的在严格模式和node环境下会遵循全局绑定规则)</p>
<h1 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h1><h2 id="case1"><a href="#case1" class="headerlink" title="case1"></a>case1</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="comment">// 独立函数调用，没有和任何对象关联</span></span><br><span class="line">  <span class="title function_">sss</span>(); <span class="comment">// window</span></span><br><span class="line">  <span class="comment">// 关联</span></span><br><span class="line">  person.<span class="title function_">sayName</span>(); <span class="comment">// person</span></span><br><span class="line">  (person.<span class="property">sayName</span>)(); <span class="comment">// person</span></span><br><span class="line">  (b = person.<span class="property">sayName</span>)(); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayName</span>();</span><br></pre></td></tr></table></figure>

<h2 id="case2"><a href="#case2" class="headerlink" title="case2"></a>case2</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定，肯定是person1</span></span><br><span class="line">person1.<span class="title function_">foo1</span>(); <span class="comment">// person1</span></span><br><span class="line"><span class="comment">// 隐式绑定和显示绑定的结合，显示绑定生效，所以是person2</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2); <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo2()是一个箭头函数，不适用所有的规则</span></span><br><span class="line">person1.<span class="title function_">foo2</span>() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// foo2依然是箭头函数，不适用于显示绑定的规则</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2) <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取到foo3，但是调用位置是全局作用于下，所以是默认绑定window</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// foo3显示绑定到person2中</span></span><br><span class="line"><span class="comment">// 但是拿到的返回函数依然是在全局下调用，所以依然是window</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 拿到foo3返回的函数，通过显示绑定到person2中，所以是person2</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo4()的函数返回的是一个箭头函数</span></span><br><span class="line"><span class="comment">// 箭头函数的执行找上层作用域，是person1</span></span><br><span class="line">person1.<span class="title function_">foo4</span>()() <span class="comment">// person1</span></span><br><span class="line"><span class="comment">// foo4()显示绑定到person2中，并且返回一个箭头函数</span></span><br><span class="line"><span class="comment">// 箭头函数找上层作用域，是person2</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2</span></span><br><span class="line"><span class="comment">// foo4返回的是箭头函数，箭头函数只看上层作用域</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2) <span class="comment">// person1</span></span><br></pre></td></tr></table></figure>

<h2 id="case-3"><a href="#case-3" class="headerlink" title="case 3"></a>case 3</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo2</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo4</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式绑定</span></span><br><span class="line">person1.<span class="title function_">foo1</span>() <span class="comment">// peron1</span></span><br><span class="line"><span class="comment">// 显示绑定优先级大于隐式绑定</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo是一个箭头函数，会找上层作用域中的this，那么就是person1</span></span><br><span class="line">person1.<span class="title function_">foo2</span>() <span class="comment">// person1</span></span><br><span class="line"><span class="comment">// foo是一个箭头函数，使用call调用不会影响this的绑定，和上面一样向上层查找</span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2) <span class="comment">// person1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用位置是全局直接调用，所以依然是window（默认绑定）</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 最终还是拿到了foo3返回的函数，在全局直接调用（默认绑定）</span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 拿到foo3返回的函数后，通过call绑定到person2中进行了调用</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo4返回了箭头函数，和自身绑定没有关系，上层找到person1</span></span><br><span class="line">person1.<span class="title function_">foo4</span>()() <span class="comment">// person1</span></span><br><span class="line"><span class="comment">// foo4调用时绑定了person2，返回的函数是箭头函数，调用时，找到了上层绑定的person2</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2</span></span><br><span class="line"><span class="comment">// foo4调用返回的箭头函数，和call调用没有关系，找到上层的person1</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2) <span class="comment">// person1</span></span><br></pre></td></tr></table></figure>

<h2 id="case-4"><a href="#case-4" class="headerlink" title="case 4"></a>case 4</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span> (name) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// obj.foo1()返回一个函数</span></span><br><span class="line"><span class="comment">// 这个函数在全局作用于下直接执行（默认绑定）</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>()() <span class="comment">// window</span></span><br><span class="line"><span class="comment">// 最终还是拿到一个返回的函数（虽然多了一步call的绑定）</span></span><br><span class="line"><span class="comment">// 这个函数在全局作用于下直接执行（默认绑定）</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo1</span>.<span class="title function_">call</span>(person2)() <span class="comment">// window</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>().<span class="title function_">call</span>(person2) <span class="comment">// person2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到foo2()的返回值，是一个箭头函数</span></span><br><span class="line"><span class="comment">// 箭头函数在执行时找上层作用域下的this，就是obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>()() <span class="comment">// obj</span></span><br><span class="line"><span class="comment">// foo2()的返回值，依然是箭头函数，但是在执行foo2时绑定了person2</span></span><br><span class="line"><span class="comment">// 箭头函数在执行时找上层作用域下的this，找到的是person2</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo2</span>.<span class="title function_">call</span>(person2)() <span class="comment">// person2</span></span><br><span class="line"><span class="comment">// foo2()的返回值，依然是箭头函数</span></span><br><span class="line"><span class="comment">// 箭头函数通过call调用是不会绑定this，所以找上层作用域下的this是obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>().<span class="title function_">call</span>(person2) <span class="comment">// obj</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/this%E6%8C%87%E9%92%88/" data-id="cldjpozuu000b98t431hpdtyj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-npm与yarn" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/npm%E4%B8%8Eyarn/" class="article-date">
  <time datetime="2023-01-31T03:19:39.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/npm%E4%B8%8Eyarn/">npm与yarn</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="常用命令和配置"><a href="#常用命令和配置" class="headerlink" title="常用命令和配置"></a>常用命令和配置</h2><h3 id="查看全局配置"><a href="#查看全局配置" class="headerlink" title="查看全局配置"></a>查看全局配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">ls</span></span><br></pre></td></tr></table></figure>

<h3 id="缓存位置及修改"><a href="#缓存位置及修改" class="headerlink" title="缓存位置及修改"></a>缓存位置及修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> cache <span class="string">&quot;D:\Program\nodejs\node_cache&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="全局安装位置及修改"><a href="#全局安装位置及修改" class="headerlink" title="全局安装位置及修改"></a>全局安装位置及修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix <span class="string">&quot;D:\Program\nodejs\node_global&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h1><h2 id="常用命令和配置-1"><a href="#常用命令和配置-1" class="headerlink" title="常用命令和配置"></a>常用命令和配置</h2><h3 id="缓存位置及修改-1"><a href="#缓存位置及修改-1" class="headerlink" title="缓存位置及修改"></a>缓存位置及修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yarn cache <span class="built_in">dir</span> <span class="comment"># 查看缓存位置</span></span><br><span class="line">yarn cache clean <span class="comment"># 清除缓存,在目录</span></span><br><span class="line">yarn config <span class="built_in">set</span> cache-folder <span class="string">&quot;D:\Program\nodejs\yarn_cache&quot;</span>  <span class="comment"># 设置D盘</span></span><br></pre></td></tr></table></figure>

<h3 id="全局安装位置及修改-1"><a href="#全局安装位置及修改-1" class="headerlink" title="全局安装位置及修改"></a>全局安装位置及修改</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn global <span class="built_in">dir</span>  <span class="comment"># 查看全局位置</span></span><br><span class="line">yarn config <span class="built_in">set</span> global-folder <span class="string">&quot;D:\Program\nodejs\yarn_global&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="重新设置bin目录"><a href="#重新设置bin目录" class="headerlink" title="重新设置bin目录"></a>重新设置bin目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn global bin <span class="comment"># 默认是 c:/,修改到 D:盘</span></span><br><span class="line">yarn config <span class="built_in">set</span> prefix <span class="string">&quot;D:\Program\nodejs\yarn_global&quot;</span> <span class="comment"># 会链到上述目录的bin文件夹，需要自行创建一个</span></span><br></pre></td></tr></table></figure>

<p>修改完bin后需要把bin文件夹对应的路径加入环境变量</p>
<h3 id="修改镜像地址（非必要）"><a href="#修改镜像地址（非必要）" class="headerlink" title="修改镜像地址（非必要）"></a>修改镜像地址（非必要）</h3><p>非必要的原因是可以用yrm进行管理，更加方便</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> registry https://registry.npm.taobao.org/ <span class="comment"># 淘宝镜像</span></span><br></pre></td></tr></table></figure>

<h1 id="yrm"><a href="#yrm" class="headerlink" title="yrm"></a>yrm</h1><p>yrm是用来管理镜像源的</p>
<p>以下是yrm的常用命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yarn global add yrm</span><br><span class="line">yrm <span class="built_in">ls</span> <span class="comment"># 列出所有可用源，安装后通常会把常用源都添加上</span></span><br><span class="line">yrm now <span class="comment"># 当前源，</span></span><br><span class="line">yrm use yarn <span class="comment"># 选择一个源</span></span><br><span class="line">yrm <span class="built_in">test</span> [<span class="built_in">source</span>] <span class="comment"># 测试所有源的响应时间，添加source可以测试指定的源</span></span><br><span class="line">yrm add source-name source-url <span class="comment"># 添加源</span></span><br><span class="line">yrm del <span class="built_in">source</span> <span class="comment"># 删除源</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/npm%E4%B8%8Eyarn/" data-id="cldjpozuw000g98t4defpcd30" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mini-vue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/mini-vue/" class="article-date">
  <time datetime="2023-01-31T03:19:18.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/mini-vue/">mini-vue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>简述</p>
<p>实现一个简洁版的Mini-Vue框架，该Vue包括三个模块</p>
<ul>
<li>渲染系统模块</li>
<li>可响应式系统模块</li>
<li>应用程序入口模块</li>
</ul>
<h1 id="渲染系统实现"><a href="#渲染系统实现" class="headerlink" title="渲染系统实现"></a>渲染系统实现</h1><p>渲染系统，该模块主要包含三个功能</p>
<ul>
<li>功能一：h函数，用于返回一个VNode对象</li>
<li>功能二：mount函数，用于将VNode挂载到DOM上</li>
<li>功能三：patch函数，用于对两个VNode进行对比，决定如何处理新的VNode</li>
</ul>
<h2 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h2><p>直接返回一个VNode对象即可</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">h</span> = (<span class="params">tag, props, children</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag,</span><br><span class="line">    props,</span><br><span class="line">    children</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Mount函数"><a href="#Mount函数" class="headerlink" title="Mount函数"></a>Mount函数</h2><ul>
<li>根据tag，创建HTML元素，并且存储到vnode的el中</li>
<li>处理props属性<ul>
<li>如果以on开头，那么监听事件</li>
<li>普通属性直接通过 setAttribute 添加即可</li>
</ul>
</li>
<li>处理子节点<ul>
<li>如果是字符串节点，那么直接设置textContent</li>
<li>如果是数组节点，那么遍历调用 mount 函数</li>
</ul>
</li>
<li>挂载vnode到指定元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mount</span> = (<span class="params">vnode, container</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// vnode -&gt; element</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> el = vnode.<span class="property">el</span> = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(vnode.<span class="property">tag</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 遍历props 存储到dom元素上</span></span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">props</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> vnode.<span class="property">props</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = vnode.<span class="property">props</span>[key]</span><br><span class="line">      <span class="comment">// 监听事件</span></span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&#x27;on&#x27;</span>)) &#123;</span><br><span class="line">        el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="title function_">setAttribute</span>(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vnode.<span class="property">children</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果是text文本直接存入textContent</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> vnode.<span class="property">children</span> === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      el.<span class="property">textContent</span> = vnode.<span class="property">children</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 递归</span></span><br><span class="line">      vnode.<span class="property">children</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">mount</span>(item, el)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  container.<span class="title function_">appendChild</span>(el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h2><p>patch函数的实现，分为两种情况</p>
<ul>
<li>n1和n2是不同类型的节点：<ul>
<li>找到n1的el父节点，删除原来的n1节点的el</li>
<li>挂载n2节点到n1的el父节点上；</li>
</ul>
</li>
<li>n1和n2节点是相同的节点：<ul>
<li>处理props的情况<ul>
<li>先将新节点的props全部挂载到el上；</li>
<li>判断旧节点的props是否不需要在新节点上，如果不需要，那么删除对应的属性；</li>
</ul>
</li>
<li>处理children的情况<ul>
<li>如果新节点是一个字符串类型，那么直接调用 el.textContent = newChildren</li>
</ul>
</li>
<li>如果新节点不同一个字符串类型：<ul>
<li>旧节点是一个字符串类型<ul>
<li>将el的textContent设置为空字符串；</li>
<li>就节点是一个字符串类型，那么直接遍历新节点，挂载到el上；</li>
</ul>
</li>
<li>旧节点也是一个数组类型<ul>
<li>取出数组的最小长度；</li>
<li>遍历所有的节点，新节点和旧节点进行path操作；</li>
<li>如果新节点的length更长，那么剩余的新节点进行挂载操作；</li>
<li>如果旧节点的length更长，那么剩余的旧节点进行卸载操作；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">patch</span> = (<span class="params">n1, n2</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// tag不相同直接移除</span></span><br><span class="line">  <span class="keyword">if</span> (n1.<span class="property">tag</span> !== n2.<span class="property">tag</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> n1ElParent = n1.<span class="property">el</span>.<span class="property">parentElement</span></span><br><span class="line">    n1ElParent.<span class="title function_">removeChild</span>(n1.<span class="property">el</span>) <span class="comment">// 移除</span></span><br><span class="line">    <span class="title function_">mount</span>(n2, n1ElParent) <span class="comment">// 重新挂载</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 取出element对象 并保存到n2中</span></span><br><span class="line">    <span class="keyword">const</span> el = n2.<span class="property">el</span> = n1.<span class="property">el</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理props</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = n1.<span class="property">props</span> || &#123;&#125;</span><br><span class="line">    <span class="keyword">const</span> newProps = n2.<span class="property">props</span> || &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加新的props</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldValue = oldProps[key]</span><br><span class="line">      <span class="keyword">const</span> newValue = newProps[key]</span><br><span class="line">      <span class="keyword">if</span> (oldValue !== newValue &amp;&amp; newValue !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&#x27;on&#x27;</span>)) &#123;</span><br><span class="line">          <span class="comment">// 卸载之前的监听</span></span><br><span class="line">          el.<span class="title function_">removeEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), oldValue)</span><br><span class="line">          el.<span class="title function_">addEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), newValue)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          el.<span class="title function_">setAttribute</span>(key, newValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移除旧的props</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = oldProps[key]</span><br><span class="line">      <span class="comment">// 如果是事件的话直接卸载</span></span><br><span class="line">      <span class="keyword">if</span> (key.<span class="title function_">startsWith</span>(<span class="string">&#x27;on&#x27;</span>)) &#123;</span><br><span class="line">        el.<span class="title function_">removeEventListener</span>(key.<span class="title function_">slice</span>(<span class="number">2</span>).<span class="title function_">toLowerCase</span>(), value)</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">if</span> (!(key <span class="keyword">in</span> newProps)) &#123;</span><br><span class="line">        el.<span class="title function_">removeAttribute</span>(key, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理children</span></span><br><span class="line">    <span class="keyword">const</span> oldChildren = n1.<span class="property">children</span> || []</span><br><span class="line">    <span class="keyword">const</span> newChildren = n2.<span class="property">children</span> || []</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新节点是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果旧节点也是字符串</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 仅在不相等时赋值</span></span><br><span class="line">        <span class="keyword">if</span> (newChildren !== oldChildren) &#123;</span><br><span class="line">          el.<span class="property">textContent</span> = newChildren</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        el.<span class="property">innerHtml</span> = newChildren</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> oldChildren === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        el.<span class="property">innerHtml</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        newChildren.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="title function_">mount</span>(item, el)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> commonLength = <span class="title class_">Math</span>.<span class="title function_">min</span>(oldChildren.<span class="property">length</span>, newChildren.<span class="property">length</span>)</span><br><span class="line">        <span class="comment">// 考虑没有key的操作 无优化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; commonLength; i += <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="title function_">patch</span>(oldChildren[i], newChildren[i])</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &gt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          newChildren.<span class="title function_">slice</span>(oldChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">mount</span>(item, el)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newChildren.<span class="property">length</span> &lt; oldChildren.<span class="property">length</span>) &#123;</span><br><span class="line">          oldChildren.<span class="title function_">slice</span>(newChildren.<span class="property">length</span>).<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            el.<span class="title function_">removeChild</span>(item.<span class="property">el</span>)</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="依赖收集系统"><a href="#依赖收集系统" class="headerlink" title="依赖收集系统"></a>依赖收集系统</h1><h2 id="响应式系统Vue2实现"><a href="#响应式系统Vue2实现" class="headerlink" title="响应式系统Vue2实现"></a>响应式系统Vue2实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Map(&#123;key: value&#125;): key是一个字符串</span></span><br><span class="line"><span class="comment">// WeakMap(&#123;key(对象): value&#125;): key是一个对象, 弱引用</span></span><br><span class="line"><span class="keyword">const</span> targetMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局存储依赖 方便获取</span></span><br><span class="line"><span class="keyword">let</span> activeEffect = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dep</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">depend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">add</span>(activeEffect)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">effect</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">effect</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDep</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="comment">// 1.根据对象(target)取出对应的Map对象</span></span><br><span class="line">  <span class="keyword">let</span> depsMap = targetMap.<span class="title function_">get</span>(target)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!depsMap) &#123;</span><br><span class="line">    depsMap = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line">    targetMap.<span class="title function_">set</span>(target, depsMap)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.取出具体的dep对象</span></span><br><span class="line">  <span class="keyword">let</span> dep = depsMap.<span class="title function_">get</span>(key)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!dep) &#123;</span><br><span class="line">    dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line">    depsMap.<span class="title function_">set</span>(key, dep)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchEffect</span>(<span class="params">effect</span>) &#123;</span><br><span class="line">  activeEffect = effect</span><br><span class="line">  <span class="title function_">effect</span>()</span><br><span class="line">  activeEffect = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2对raw进行数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(raw).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(raw, key)</span><br><span class="line">    <span class="keyword">let</span> value = raw[key]</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(raw, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        dep.<span class="title function_">depend</span>()</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value !== newValue) &#123;</span><br><span class="line">          value = newValue;</span><br><span class="line">          dep.<span class="title function_">notify</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> raw</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------下面是测试代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> foo = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="number">12.3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dep = <span class="keyword">new</span> <span class="title class_">Dep</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">// watchEffect1</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;effect1:&quot;</span>, info.<span class="property">counter</span> * <span class="number">2</span>, info.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// watchEffect2</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;effect2:&quot;</span>, info.<span class="property">counter</span> * info.<span class="property">counter</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// watchEffect3</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;effect3:&quot;</span>, info.<span class="property">counter</span> + <span class="number">10</span>, info.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;effect4:&quot;</span>, foo.<span class="property">height</span>, info.<span class="property">name</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">info.<span class="property">counter</span> += <span class="number">1</span></span><br><span class="line"><span class="comment">// dep.notify()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// info.name = &#x27;李四&#x27;</span></span><br><span class="line"><span class="comment">// dep.notify()</span></span><br></pre></td></tr></table></figure>

<h2 id="响应式系统Vue3实现"><a href="#响应式系统Vue3实现" class="headerlink" title="响应式系统Vue3实现"></a>响应式系统Vue3实现</h2><p>与vue2中不同是，vue3使用proxy劫持对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">raw</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(raw, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(raw, key)</span><br><span class="line">      dep.<span class="title function_">depend</span>()</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, value, receiver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="title function_">getDep</span>(raw, key)</span><br><span class="line">      <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, value, receiver)</span><br><span class="line">      dep.<span class="title function_">notify</span>()</span><br><span class="line">      <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用proxy的原因"><a href="#使用proxy的原因" class="headerlink" title="使用proxy的原因"></a>使用proxy的原因</h2><ul>
<li>Object.definedProperty 是劫持对象的属性时，如果新增元素<ul>
<li>那么Vue2需要再次 调用definedProperty，而 Proxy 劫持的是整个对象，不需要做特殊处理</li>
</ul>
</li>
<li>修改对象的不同<ul>
<li>使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截</li>
<li>而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截</li>
</ul>
</li>
<li>Proxy 能观察的类型比 defineProperty 更丰富<ul>
<li>has：in操作符的捕获器</li>
<li>deleteProperty：delete 操作符的捕捉器</li>
<li>还有其他proxy的劫持器</li>
</ul>
</li>
<li>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化</li>
<li>缺点：Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9</li>
</ul>
<h1 id="应用程序入口模块"><a href="#应用程序入口模块" class="headerlink" title="应用程序入口模块"></a>应用程序入口模块</h1><p>从框架的层面来说，我们需要有两部分内容</p>
<ul>
<li>createApp用于创建一个app对象</li>
<li>该app对象有一个mount方法，可以将根组件挂载到某一个dom元素上</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createApp</span>(<span class="params">rootComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="title function_">mount</span>(<span class="params">selector</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> container = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(selector);</span><br><span class="line">      <span class="keyword">let</span> isMounted = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">let</span> oldVNode = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="title function_">watchEffect</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isMounted) &#123;</span><br><span class="line">          oldVNode = rootComponent.<span class="title function_">render</span>();</span><br><span class="line">          <span class="title function_">mount</span>(oldVNode, container);</span><br><span class="line">          isMounted = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> newVNode = rootComponent.<span class="title function_">render</span>();</span><br><span class="line">          <span class="title function_">patch</span>(oldVNode, newVNode);</span><br><span class="line">          oldVNode = newVNode;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/mini-vue/" data-id="cldjpozus000898t41ls3ehsf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js中的异步" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2023-01-31T03:19:11.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/">js中的异步</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JS中的异步"><a href="#JS中的异步" class="headerlink" title="JS中的异步"></a>JS中的异步</h1><p>js单线程的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段Javascript代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。</p>
<p>为了解决这个问题，Javascript语言将任务的执行模式分成两种：同步（Synchronous）和异步（Asynchronous）。</p>
<ul>
<li>“同步模式”就是上一段的模式，后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的；</li>
<li>“异步模式”则完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</li>
</ul>
<p>“异步模式”非常重要。在浏览器端，耗时很长的操作都应该异步执行，避免浏览器失去响应，最好的例子就是Ajax操作。在服务器端，”异步模式”甚至是唯一的模式，因为执行环境是单线程的，如果允许同步执行所有http请求，服务器性能会急剧下降，很快就会失去响应。</p>
<h3 id="回调函数callback"><a href="#回调函数callback" class="headerlink" title="回调函数callback"></a>回调函数callback</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn1&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">callback</span>()</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn2</span>(fn1)</span><br></pre></td></tr></table></figure>

<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以去耦合（Decoupling），有利于实现模块化。</p>
<p>缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。 由于没有统一中心处理，会导致事件触发后无法简单定位到是谁接收了。</p>
<h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h3><p>我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。</p>
<p>这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="Promise-A"><a href="#Promise-A" class="headerlink" title="Promise/A+"></a>Promise/A+</h3><p>Promise本意是承诺，在程序中的意思就是承诺我过一段时间后会给你一个结果。 什么时候会用到过一段时间？答案是异步操作，异步是指可能比较长时间才有结果的才做，例如网络请求、读取本地文件等。</p>
<p>Promise 规范有很多，如Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+。ES6中采用了 Promise/A+ 规范。以下均以Promise/A+为基础展开。</p>
<p><strong>promise和async/await后续小技巧会在后面补充</strong></p>
<h4 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h4><p>Promise一共有三种状态，对象的状态不受外界影响</p>
<ul>
<li>Pending: Promise对象实例创建时候的初始状态</li>
<li>Fulfilled: 可以理解为成功的状态</li>
<li>Rejected: 可以理解为失败的状态</li>
</ul>
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，即Promise<strong>只能从Pending变为Fulfilled/Rejected任意一个</strong>，并且一旦变更不可逆转（即不能从Fulfilled/Rejected变回Pending）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态一经变动不可逆转</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">reject</span>(<span class="string">&#x27;reject&#x27;</span>)</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="string">&#x27;resolve&#x27;</span>) <span class="comment">// 无效代码</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)).<span class="title function_">catch</span>(<span class="function"><span class="params">rej</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(rej))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结果为 reject</span></span><br></pre></td></tr></table></figure>

<h4 id="Promise的执行顺序与链式调用"><a href="#Promise的执行顺序与链式调用" class="headerlink" title="Promise的执行顺序与链式调用"></a>Promise的执行顺序与链式调用</h4><ul>
<li>每次调用返回的都是一个新的Promise实例(这就是then可用链式调用的原因)</li>
<li>如果then中返回的是一个结果的话会把这个结果传递下一次then中的成功回调</li>
<li>如果then中出现异常,会走下一个then的失败回调</li>
<li>在 then中使用了return，那么 return 的值会被Promise.resolve() 包装（见case1,2）</li>
<li>then中可以不传递参数，如果不传递会透到下一个then中（见case3）</li>
<li>catch 会捕获到没有捕获的异常</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1 then中的return会被包裹成Promise.resolve()</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;r1&#x27;</span>, res)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> <span class="comment">//包装成 Promise.resolve(2)</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="number">3</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;r2&#x27;</span>, res))</span><br><span class="line"></span><br><span class="line"><span class="comment">// case2 链式调用</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">1</span>)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span> <span class="comment">// 2</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;My Error&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(err) <span class="comment">// Error: My Error</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(x + <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">1</span> <span class="comment">// 2 </span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">x</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(x)) <span class="comment">//2</span></span><br><span class="line">.<span class="title function_">catch</span>(<span class="variable language_">console</span>.<span class="property">error</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// case3 失败回调会一路找到最近的catch</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;rej&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>() <span class="comment">//then中出现异常,会走下一个then的失败回调</span></span><br><span class="line">&#125;) <span class="comment">//由于下一个then没有失败回调，就会继续往下找，如果都没有，就会被catch捕获到</span></span><br><span class="line">.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>()</span><br><span class="line">.<span class="title function_">then</span>(<span class="literal">null</span>, <span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;then&#x27;</span>, err)<span class="comment">// then error</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="keyword">function</span>(<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="Promise的优缺点"><a href="#Promise的优缺点" class="headerlink" title="Promise的优缺点"></a>Promise的优缺点</h4><p>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise 对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise 也有一些缺点。</p>
<ul>
<li>没有原生方法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li>
<li>当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p>取消promise需要通过其他方式间接取消<br>以下是通过promise.race()的取消</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过race取消promise</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cancelPromise</span> (pName) &#123;</span><br><span class="line">  <span class="keyword">const</span> abort = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">_, _abort</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">_abort</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;abort&quot;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;the promise is aborted&quot;</span>,</span><br><span class="line">      <span class="attr">aborted</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="title class_">Promise</span>.<span class="title function_">race</span>([pName, abort]).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)).<span class="title function_">catch</span>(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(err))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生成器Generators-yield"><a href="#生成器Generators-yield" class="headerlink" title="生成器Generators/ yield"></a>生成器Generators/ yield</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，Generator 最大的特点就是可以控制函数的执行。</p>
<ul>
<li>语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</li>
<li>Generator 函数除了状态机，还是一个遍历器对象生成函数。</li>
<li>可暂停函数, yield可暂停，next方法可启动，每次返回的是yield后的表达式结果。</li>
<li>yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> *<span class="title function_">foo</span>(<span class="params">x</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span> (x + <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">let</span> z = <span class="keyword">yield</span> (y / <span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> x + y + z</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> it = <span class="title function_">foo</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(it.<span class="title function_">next</span>(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>实际上手动迭代Generator 函数很麻烦，实现逻辑有点绕，而实际开发一般会配合 <code>co</code> 库去使用。<br>co是一个为Node.js和浏览器打造的基于生成器的流程控制工具，借助于Promise，你可以使用更加优雅的方式编写非阻塞代码。</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>使用async/await，你可以轻松地达成之前使用生成器和co函数所做到的工作,它有如下特点：</p>
<ul>
<li>async/await是基于Promise实现的，它不能用于普通的回调函数。</li>
<li>async/await与Promise一样，是非阻塞的。</li>
<li>async/await使得异步代码看起来像同步代码</li>
</ul>
<h4 id="async的作用"><a href="#async的作用" class="headerlink" title="async的作用"></a>async的作用</h4><p>一个函数如果加上 async ，那么该函数就会返回一个 Promise。<br>如果在函数中 return 一个直接量，async 会把这个直接量通过<code>Promise.resolve()</code>封装成 Promise 对象。 <code>Promise.resolve(x)</code>可以看作是<code>new Promise(resolve =&gt; resolve(x))</code>的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值为promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">async1</span>()) <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>由于返回的本质是Promise，因此可以用then()进行链式触发</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">async1</span>().<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res)) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>如果 async 函数没有返回值，它会返回<code>Promise.resolve(undefined)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">async1</span>()) <span class="comment">// Promise &#123; undefined &#125;</span></span><br></pre></td></tr></table></figure>

<p>所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>
<h4 id="await的作用"><a href="#await的作用" class="headerlink" title="await的作用"></a>await的作用</h4><p>一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>
<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。<br>注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，<strong>await 后面实际是可以接普通函数调用或者直接量的。</strong> 所以下面这个示例完全可以正确运行</p>
<p><strong>一个函数如果加上 async ，那么该函数就会返回一个 Promise</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值为promise</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">async1</span>()) <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果转化为promise的话</span></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    <span class="title function_">res</span>(<span class="string">&#x27;res p1&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">    <span class="title function_">res</span>(<span class="string">&#x27;res p2&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async start&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> res1 = <span class="keyword">await</span> p1</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res1)</span><br><span class="line">  <span class="keyword">const</span> res2 = <span class="keyword">await</span> p2</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res2)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async end&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于</span></span><br><span class="line">  <span class="comment">// p1.then((res1) =&gt; &#123;</span></span><br><span class="line">  <span class="comment">//   console.log(res1)</span></span><br><span class="line">  <span class="comment">//   p2.then((res2)=&gt; &#123;</span></span><br><span class="line">  <span class="comment">//     console.log(res2)</span></span><br><span class="line">  <span class="comment">//     console.log(&#x27;async end&#x27;)</span></span><br><span class="line">  <span class="comment">//   &#125;)</span></span><br><span class="line">  <span class="comment">// &#125;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">async2</span>()</span><br><span class="line"><span class="comment">// async start</span></span><br><span class="line"><span class="comment">// p1</span></span><br><span class="line"><span class="comment">// res p1</span></span><br><span class="line"><span class="comment">// p2</span></span><br><span class="line"><span class="comment">// res p2</span></span><br><span class="line"><span class="comment">// async end</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/js%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5/" data-id="cldjpozut000a98t43bircxcm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端中的模块化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/" class="article-date">
  <time datetime="2023-01-31T03:19:02.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/">前端中的模块化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="js模块导入方案简介"><a href="#js模块导入方案简介" class="headerlink" title="js模块导入方案简介"></a>js模块导入方案简介</h1><p>ES6之前已经出现了js模块加载的方案，最主要的是CommonJS和AMD规范。</p>
<p>commonjs主要应用于服务器，实现同步加载，如nodejs。</p>
<p>AMD规范应用于浏览器，如requirejs，为异步加载。</p>
<p>同时还有CMD规范，为同步加载方案如seaJS。</p>
<h2 id="require-exports"><a href="#require-exports" class="headerlink" title="require/exports"></a>require/exports</h2><p>填补了JS没有模块的空缺，它的目标是让JS不止在浏览器中运行，可以在各个地方都能运行，或者说是提供一个类似Python，Ruby和Java标准库。</p>
<p>而NodeJS是以CommonJS规范实现，Webpack也是以CommonJS规范书写的</p>
<ul>
<li>node.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。</li>
<li>CommonJS定义的模块分为:{模块引用(require)} {模块定义(exports)} {模块标识(module)}</li>
</ul>
<h2 id="import-export"><a href="#import-export" class="headerlink" title="import/export"></a>import/export</h2><p>ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6模块主要有两个功能：export和import</p>
<p>export用于对外输出本模块（一个文件可以理解为一个模块）变量的接口</p>
<p>import用于在一个模块中加载另一个含有export接口的模块。</p>
<p>也就是说使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）</p>
<p>import的加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。但是这样会造成import时无法动态加载</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><p>遵循规范</p>
<ul>
<li>require 是 AMD规范引入方式</li>
<li>import是es6的一个语法标准，如果要兼容浏览器的话必须转化成es5的语法</li>
</ul>
</li>
<li><p>调用时间</p>
<ul>
<li>require是运行时调用，所以require理论上可以运用在代码的任何地方</li>
<li>import是编译时调用，所以必须放在文件开头，且由于是编译时调用，因此无法动态加载</li>
</ul>
</li>
<li><p>本质</p>
<ul>
<li>require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量</li>
<li>import是解构过程，但是目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，import语法会被转码为require</li>
</ul>
</li>
</ul>
<h2 id="是否可以混合着用"><a href="#是否可以混合着用" class="headerlink" title="是否可以混合着用"></a>是否可以混合着用</h2><p>按照规范<strong>module.exports =&gt;require，export=&gt;import</strong>，但是现在开发为了兼容低版本的JS引擎会对import进行降级处理，会把import转换成require；这样就造成了各种方法可以混合使用</p>
<p>需要注意的是require是把所有模块加载进去，与import * 基本相同，但是import * 会增加default属性。import需要指定模块名，如果不存在会返回undefined。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/%E5%89%8D%E7%AB%AF%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/" data-id="cldjpozv0000s98t487yx9slt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/" rel="tag">模块化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-element-ui源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/element-ui%E6%BA%90%E7%A0%81/" class="article-date">
  <time datetime="2023-01-31T03:18:44.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/element-ui%E6%BA%90%E7%A0%81/">element-ui源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="clickoutside是什么"><a href="#clickoutside是什么" class="headerlink" title="clickoutside是什么"></a>clickoutside是什么</h2><p>用来处理目标节点之外的点击事件，常用来处理下拉菜单等展开内容的关闭</p>
<h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>具体参考<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/custom-directive.html">自定义指令 — Vue.js</a></p>
<h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p>
<ul>
<li><p><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
</li>
<li><p><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p>
</li>
<li><p><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。</p>
</li>
<li><p><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</p>
</li>
<li><p><code>unbind</code>：只调用一次，指令与元素解绑时调用。</p>
</li>
</ul>
<h3 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h3><p>指令钩子函数会被传入以下参数：</p>
<ul>
<li><p><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM。</p>
</li>
<li><p><code>binding</code>：一个对象，包含以下 property：</p>
</li>
<li><p><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</p>
<ul>
<li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li>
</ul>
</li>
<li><p><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</p>
<ul>
<li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li>
<li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li>
<li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>&#123; foo: true, bar: true &#125;</code>。</li>
</ul>
</li>
<li><p><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#VNode-%E6%8E%A5%E5%8F%A3">VNode API</a> 来了解更多详情。</p>
</li>
<li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p>
</li>
</ul>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>通过冒泡机制收集鼠标点击事件，通过这些事件判断点击元素B是否在绑定元素A上（包括B是否为A本身），如果不在时触发回调。</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>对document绑定mousedown和mouseup事件收集当前点击的元素（此处利用的冒泡机制实现收集）。</p>
<p>只有当mousedown和mouseup对应的元素都在绑定元素中时才不触发回调（具体参考源码的判断条件）。</p>
<p>理论上clickoutside只能也只需要绑定一个元素作为inside，但是实际上会有一些奇葩的操作，比如点击鼠标后拖动到別的元素再松开。</p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; on &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui/src/utils/dom&#x27;</span>; <span class="comment">// element-ui实现的绑定事件方法，兼容ie</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> nodeList = []; <span class="comment">// 元素收集器，搜集所有绑定了clickoutside的元素</span></span><br><span class="line"><span class="keyword">const</span> ctx = <span class="string">&#x27;@@clickoutsideContext&#x27;</span>; <span class="comment">// 命名空间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> startClick;</span><br><span class="line"><span class="keyword">let</span> seed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过事件冒泡获取mousedown的元素，保存在startClick中</span></span><br><span class="line">!<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$isServer</span> &amp;&amp; <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mousedown&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> (startClick = e));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给所有绑定了clickoutside的元素绑定事件documentHandler</span></span><br><span class="line">!<span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$isServer</span> &amp;&amp; <span class="title function_">on</span>(<span class="variable language_">document</span>, <span class="string">&#x27;mouseup&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// documentHandler(绑定了clickoutside的元素的mouseup事件，mousedown的元素)</span></span><br><span class="line">  nodeList.<span class="title function_">forEach</span>(<span class="function"><span class="params">node</span> =&gt;</span> node[ctx].<span class="title function_">documentHandler</span>(e, startClick));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="comment">// &#123;dom元素, 指令绑定参数, 虚拟dom&#125;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createDocumentHandler</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="params">mouseup = &#123;&#125;, mousedown = &#123;&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vnode || <span class="comment">// 虚拟dom</span></span><br><span class="line">      !vnode.<span class="property">context</span> || <span class="comment">// 虚拟dom对应的vue对象（上下文）</span></span><br><span class="line">      !mouseup.<span class="property">target</span> || <span class="comment">// 鼠标松开对应的dom</span></span><br><span class="line">      !mousedown.<span class="property">target</span> || <span class="comment">// 鼠标点击对应dom</span></span><br><span class="line">      el.<span class="title function_">contains</span>(mouseup.<span class="property">target</span>) || <span class="comment">// 是否为绑定元素子元素</span></span><br><span class="line">      el.<span class="title function_">contains</span>(mousedown.<span class="property">target</span>) || <span class="comment">// 是否为绑定元素子元素</span></span><br><span class="line">      el === mouseup.<span class="property">target</span> || <span class="comment">// 是否为绑定元素本身</span></span><br><span class="line">      (vnode.<span class="property">context</span>.<span class="property">popperElm</span> &amp;&amp;</span><br><span class="line">      (vnode.<span class="property">context</span>.<span class="property">popperElm</span>.<span class="title function_">contains</span>(mouseup.<span class="property">target</span>) ||</span><br><span class="line">      vnode.<span class="property">context</span>.<span class="property">popperElm</span>.<span class="title function_">contains</span>(mousedown.<span class="property">target</span>)))) <span class="keyword">return</span>; <span class="comment">// 判断是否点击在下拉菜单的上，如果是，也是没有点击在绑定元素外部，不执行clickoutside指令内容</span></span><br><span class="line">    <span class="keyword">if</span> (binding.<span class="property">expression</span> &amp;&amp;</span><br><span class="line">      el[ctx].<span class="property">methodName</span> &amp;&amp;</span><br><span class="line">      vnode.<span class="property">context</span>[el[ctx].<span class="property">methodName</span>]) &#123;</span><br><span class="line">      vnode.<span class="property">context</span>[el[ctx].<span class="property">methodName</span>]();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      el[ctx].<span class="property">bindingFn</span> &amp;&amp; el[ctx].<span class="title function_">bindingFn</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * v-clickoutside</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc</span> 点击元素外面才会触发的事件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example</span></span></span><br><span class="line"><span class="comment"> * vue</span></span><br><span class="line"><span class="comment"> * &lt;div v-element-clickoutside=&quot;handleClose&quot;&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">bind</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    nodeList.<span class="title function_">push</span>(el); <span class="comment">// 加入新的绑定元素</span></span><br><span class="line">    <span class="keyword">const</span> id = seed++; <span class="comment">// 全局id</span></span><br><span class="line">    el[ctx] = &#123;</span><br><span class="line">      id,</span><br><span class="line">      <span class="attr">documentHandler</span>: <span class="title function_">createDocumentHandler</span>(el, binding, vnode),</span><br><span class="line">      <span class="attr">methodName</span>: binding.<span class="property">expression</span>, <span class="comment">// 字符串形式的指令表达式。例如 v-my-directive=“1 + 1” 中，表达式为 “1 + 1”。</span></span><br><span class="line">      <span class="attr">bindingFn</span>: binding.<span class="property">value</span> <span class="comment">// 指令的绑定值，例如：v-my-directive=“1 + 1” 中，绑定值为 2。</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">update</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    el[ctx].<span class="property">documentHandler</span> = <span class="title function_">createDocumentHandler</span>(el, binding, vnode);</span><br><span class="line">    el[ctx].<span class="property">methodName</span> = binding.<span class="property">expression</span>;</span><br><span class="line">    el[ctx].<span class="property">bindingFn</span> = binding.<span class="property">value</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">unbind</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = nodeList.<span class="property">length</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (nodeList[i][ctx].<span class="property">id</span> === el[ctx].<span class="property">id</span>) &#123;</span><br><span class="line">        nodeList.<span class="title function_">splice</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> el[ctx];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/element-ui%E6%BA%90%E7%A0%81/" data-id="cldjpozuk000098t4d3pffhf1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/element-ui/" rel="tag">element-ui</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-docker-从入门到入土" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/docker-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/" class="article-date">
  <time datetime="2023-01-31T03:18:32.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/docker-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/">docker-从入门到入土</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="docker是什么，用来干什么"><a href="#docker是什么，用来干什么" class="headerlink" title="docker是什么，用来干什么"></a>docker是什么，用来干什么</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。<br>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。<br>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<hr>
<p>以前如果要在一台机上做容器分割使用虚拟机，无论是需要的运行资源（内存和cpu）还是存储资源都比较大，docker的出现使上述成本大大降低</p>
<h1 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h1><p>只写ubuntu系统下的安装，window或centos平台请百度</p>
<h2 id="服务器连接软件推荐"><a href="#服务器连接软件推荐" class="headerlink" title="服务器连接软件推荐"></a>服务器连接软件推荐</h2><p>ssh链接推荐使用[mobaxterm]<a target="_blank" rel="noopener" href="https://mobaxterm.mobatek.net/%5D">[https://mobaxterm.mobatek.net/]</a></p>
<p>文件传输推荐使用[winScp]<a target="_blank" rel="noopener" href="https://winscp.net/eng/docs/lang:chs%5D">[https://winscp.net/eng/docs/lang:chs]</a></p>
<h2 id="配置镜像源"><a href="#配置镜像源" class="headerlink" title="配置镜像源"></a>配置镜像源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置国内镜像源</span></span><br><span class="line"><span class="comment"># 如果是购买云服务器的话，通常已经帮你配置好了，这一步可以跳过</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先备份源列表</span></span><br><span class="line">sudo <span class="built_in">cp</span> /etc/apt/sources.list /etc/apt/sources.list_backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开sources.list文件修改</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用下面阿里原替换掉文件中所有的内容，保存编辑好的文件</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse </span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse </span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后刷新列表，注意一定要执行刷新</span></span><br><span class="line">sudo apt-get update <span class="comment"># 更新源的软件列表</span></span><br><span class="line">sudo apt-get upgrade <span class="comment"># 可选但不推荐，更新所有软件</span></span><br></pre></td></tr></table></figure>

<h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># apt升级</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖 </span></span><br><span class="line"><span class="comment"># apt-transport-https apt支持https</span></span><br><span class="line"><span class="comment"># ca-certificates 管理ca证书</span></span><br><span class="line"><span class="comment"># curl 命令行下的url请求工具(包括文件传输等多种服务层协议),本次安装用于获取密钥</span></span><br><span class="line"><span class="comment"># software-properties-common 用于添加ppa源的小工具</span></span><br><span class="line">sudo apt-get install apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载软件包的合法性，需要添加软件源的 GPG 密钥 </span></span><br><span class="line">curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line"></span><br><span class="line"><span class="comment"># source.list 中添加 Docker 软件源 </span></span><br><span class="line">sudo add-apt-repository <span class="string">&quot;deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/ubuntu <span class="subst">$(lsb_release -cs)</span> stable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 Docker CE </span></span><br><span class="line">sudo apt-get update </span><br><span class="line">sudo apt-get install docker-ce </span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Docker CE </span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker </span><br><span class="line">sudo systemctl start docker </span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 docker 用户组 $user为需要添加的用户名</span></span><br><span class="line">sudo groupadd docker sudo usermod -aG docker <span class="variable">$USER</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># Helloworld测试 </span></span><br><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure>

<p>通常来说 在新机器上安装会比较顺利</p>
<p>不过在旧机器上可能跟会出现各种各样的问题，其中最常见的就是python版本问题<br>具体表现如下</p>
<h2 id="安装过程可能出现的问题"><a href="#安装过程可能出现的问题" class="headerlink" title="安装过程可能出现的问题"></a>安装过程可能出现的问题</h2><h3 id="lsb-release-command-not-found"><a href="#lsb-release-command-not-found" class="headerlink" title="lsb_release: command not found"></a>lsb_release: command not found</h3><p>引起原因</p>
<ol>
<li>没有安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">lsb_release -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果上述命令也是command not found时，安装</span></span><br><span class="line">sudo apt-get install lsb-core <span class="comment"># ubuntu环境，centos和redhat请自行百度</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>pythone版本问题</li>
</ol>
<p>如果在1之后仍未解决时，可能为python版本问题，即同时安装了python2和pythone3<br>导致<br>移动pythone3下的lsb_release到/usr/bin目录即可</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制到当前目录</span></span><br><span class="line">sudo <span class="built_in">cp</span> /usr/lib/python3/dist-packages/lsb_release.py /usr/bin</span><br></pre></td></tr></table></figure>

<h3 id="No-module-named-‘softwareproperties’"><a href="#No-module-named-‘softwareproperties’" class="headerlink" title="No module named ‘softwareproperties’"></a>No module named ‘softwareproperties’</h3><p>引起原因：python版本问题，即同时安装了python2和pythone3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改add-apt-repository引用python版本</span></span><br><span class="line">sudo vim /usr/bin/add-apt-repository</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改头部引用的python,版本为你目前的python3对应版本</span></span><br><span class="line"><span class="comment"># #! /usr/bin/python3.5</span></span><br></pre></td></tr></table></figure>

<h2 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h2><p>如果觉得速度理想的时候加<br>以下方法针对Ubuntu16.04+、Debian8+、CentOS7</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建或打开daemon.json</span></span><br><span class="line">sudo vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入如下内容</span></span><br><span class="line">&#123; <span class="string">&quot;registry-mirrors&quot;</span>: [ <span class="string">&quot;https://dockerhub.azk8s.cn&quot;</span>, <span class="string">&quot;https://reg-mirror.qiniu.com&quot;</span> ] &#125;</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload <span class="comment"># 重新载入镜像源</span></span><br><span class="line">sudo systemctl restart docker <span class="comment"># 重启docker服务</span></span><br></pre></td></tr></table></figure>

<h1 id="docker基本使用"><a href="#docker基本使用" class="headerlink" title="docker基本使用"></a>docker基本使用</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/docker-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F/" data-id="cldjpozuq000398t49ry75l6c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-composition-api" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/composition-api/" class="article-date">
  <time datetime="2023-01-31T03:18:01.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/composition-api/">composition-api</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Composition-API简述"><a href="#Composition-API简述" class="headerlink" title="Composition API简述"></a>Composition API简述</h2><p>Composition API字面意思是组合API，它是为了实现基于函数的逻辑复用机制而产生的。</p>
<h2 id="Options-API的弊端"><a href="#Options-API的弊端" class="headerlink" title="Options API的弊端"></a>Options API的弊端</h2><p>在Vue2中，我们编写组件的方式是Options API：</p>
<ul>
<li>Options API的一大特点就是在对应的属性中编写对应的功能模块，这样的好处是对于属性相同的代码管理方便</li>
<li>比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命周期钩子</li>
</ul>
<p>但是这种代码有一个很大的弊端：</p>
<ul>
<li>当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中</li>
<li>当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散</li>
<li>即使我们对组件尽可能拆分细致，抽取时通常会连同视图部分也一起抽取，mixin虽然能帮助我们抽取公共方法，不过我们更希望是通过一种工厂函数方式生成对面的逻辑对象</li>
<li>尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的（阅读组件的其他人）</li>
</ul>
<p>下面我们来看一个非常大的组件，其中的逻辑功能按照颜色进行了划分</p>
<ul>
<li>碎片化的代码使用理解和维护这个复杂的组件变得异常困难，并且隐藏了潜在的逻辑问题</li>
<li>并且当我们处理单个逻辑关注点时，需要<strong>不断的跳到相应的代码块中</strong></li>
</ul>
<h2 id="Composition-API的优劣"><a href="#Composition-API的优劣" class="headerlink" title="Composition API的优劣"></a>Composition API的优劣</h2><p>Composition API的出现是为了解决Options API的弊端，即对逻辑相同的代码(主要是js)提取，使得我们能对组件进行更为细致的拆分，并且可以通过工厂的方式使得组件变得更加灵活，可维护性更高</p>
<p>不过因为相较于Options API，Composition API自由度更高。如果没有统一风格维护的话代码可读性可能比Options API更差</p>
<h1 id="Composition-API的使用"><a href="#Composition-API的使用" class="headerlink" title="Composition API的使用"></a>Composition API的使用</h1><h2 id="setup函数"><a href="#setup函数" class="headerlink" title="setup函数"></a>setup函数</h2><p>编写Composition API的地方，目前有两种方式：</p>
<ul>
<li>options中添加setup函数选项</li>
<li>script中添加setup选项，vue3新出的一个语法糖</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 第一种 --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    setup() &#123;</span><br><span class="line">        // 编写setup代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 第二种 --&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">// 编写setup代码</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="setup函数的参数"><a href="#setup函数的参数" class="headerlink" title="setup函数的参数"></a>setup函数的参数</h3><p>主要有两个参数</p>
<ul>
<li>props：父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取<ul>
<li>对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义</li>
<li>并且在template中依然是可以正常去使用props中的属性</li>
<li>如果我们在setup函数中想要使用props，<strong>那么不可以通过this 去获取</strong></li>
<li>因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可</li>
</ul>
</li>
<li>context：也称之为是一个SetupContext，它里面包含三个属性<ul>
<li>attrs：所有的非prop的attribute</li>
<li>slots：父组件传递过来的插槽</li>
<li>emit：当我们组件内部需要发出事件时会用到emit</li>
</ul>
</li>
</ul>
<h3 id="setup函数的返回值"><a href="#setup函数的返回值" class="headerlink" title="setup函数的返回值"></a>setup函数的返回值</h3><p>setup的返回值可以在模板template中被使用，也就是说我们可以通过setup的返回值来替代data/methods等选项</p>
<p>对于一个定义的变量来说，默认情况下，Vue并不会跟踪它的变化，来引起界面的响应式操作，因此需要对变量进行响应式处理</p>
<h3 id="setup函数所在生命周期"><a href="#setup函数所在生命周期" class="headerlink" title="setup函数所在生命周期"></a>setup函数所在生命周期</h3><p>setup函数处于beforeCreate 和 created之间运行<br>此时this并没有指向当前组件实例，并且在setup被调用之前，data、computed、methods等都没有被解析</p>
<p>因此setup函数中不能使用this</p>
<p>源码中调用顺序如下</p>
<ul>
<li>调用createComponentInstance创建组件实例</li>
<li>调用setupComponent初始化component内部操作</li>
<li>调用setupStatefulComponent初始化有状态的组件</li>
<li>在setupStatefulComponent取出了setup函数</li>
<li>通过callWithErrorHandling的函数执行setup</li>
</ul>
<h2 id="响应式数据"><a href="#响应式数据" class="headerlink" title="响应式数据"></a>响应式数据</h2><p>vue3中对于响应式绑定使用的是proxy，<strong>并且单独抽出一个包@vue/reactivity</strong>，下面只简述使用</p>
<h3 id="ReactiveAPI"><a href="#ReactiveAPI" class="headerlink" title="ReactiveAPI"></a>ReactiveAPI</h3><p>如果想为在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数<br>reactive接受一个对象，返回一个proxy，变成一个响应式数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="reactive其他api"><a href="#reactive其他api" class="headerlink" title="reactive其他api"></a>reactive其他api</h4><ul>
<li>isProxy<ul>
<li>检查对象是否是由reactive 或readonly创建的proxy</li>
</ul>
</li>
<li>isReactive：检查对象是否是由reactive创建的响应式代理<ul>
<li>检查对象是否是由reactive创建的响应式代理</li>
<li>如果该代理是readonly建的，但包裹了由reactive 创建的另一个代理，它也会返回true</li>
</ul>
</li>
<li>toRaw<ul>
<li>返回reactive 或readonly代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）</li>
</ul>
</li>
<li>shallowReactive<ul>
<li>创建一个响应式代理，它跟踪其自身property 的响应性，但不执行嵌套对象的深层响应式转换(深层还是原生对象)</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, isProxy, isReactive, toRaw, shallowReactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">24</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;李四&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">15</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isProxy&#x27;</span>, <span class="title function_">isProxy</span>(state)) <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isReactive&#x27;</span>, <span class="title function_">isReactive</span>(state)) <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toRaw&#x27;</span>, <span class="title function_">toRaw</span>(state)) <span class="comment">// toRaw &#123;name: &#x27;张三&#x27;, age: 24, children: Array(1)&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;shallowReactive&#x27;</span>, <span class="title function_">shallowReactive</span>(state)) <span class="comment">// shallowReactive proxy&#123;name: &#x27;张三&#x27;, age: 24, children: Array(1)&#125;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toRaw-&gt;isProxy&#x27;</span>, <span class="title function_">isProxy</span>(<span class="title function_">toRaw</span>(state))) <span class="comment">// false</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toRaw-&gt;isReactive&#x27;</span>, <span class="title function_">isReactive</span>(<span class="title function_">toRaw</span>(state))) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> child = <span class="title function_">shallowReactive</span>(<span class="title function_">toRaw</span>(state)).<span class="property">children</span>[<span class="number">0</span>] <span class="comment">// 先获得原始对象 然后浅层链接</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addAge</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line">    state.<span class="property">age</span> += <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    state,</span><br><span class="line">    child,</span><br><span class="line">    addAge</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="RefAPI"><a href="#RefAPI" class="headerlink" title="RefAPI"></a>RefAPI</h3><p>reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型，如果我们传入一个基本数据类型（String、Number、Boolean）会报一个警告</p>
<p>Vue3给我们提供了另外一个API：ref API</p>
<ul>
<li>ref会返回一个可变的响应式对象，该对象作为一个响应式的引用维护着它内部的值，这就是ref名称的来源</li>
<li>它内部的值是在ref的value属性中被维护的</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> message = <span class="title function_">ref</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ref使用注意事项"><a href="#ref使用注意事项" class="headerlink" title="ref使用注意事项"></a>ref使用注意事项</h4><ul>
<li>在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以我们并不需要在模板中通过ref.value的方式来使用</li>
<li>setup 函数内部，它依然是一个ref引用，所以对其进行操作时，我们依然需要使用ref.value的方式</li>
</ul>
<h4 id="ref自动解包"><a href="#ref自动解包" class="headerlink" title="ref自动解包"></a>ref自动解包</h4><p><strong>模板中的解包是浅层的解包</strong> 如果我们将ref放到一个reactive的属性当中，那么在模板中使用时，它会自动解包</p>
<h4 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h4><p>如果使用ES6的解构语法，对<strong>reactive返回的对象</strong>进行解构获取值，<strong>那么之后无论是修改结构后的变量，还是修改reactive返回的state对象，数据都不再是响应式的</strong></p>
<p>Vue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref</p>
<p>这种做法相当于已经在state.name和ref.value之间建立了链接，任何一个修改都会引起另外一个变化</p>
<p><strong>需要注意的是toRefs包裹的对象必须是reactive，否则无法建立链接，即返回值虽然是proxy但是不是响应式数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age &#125; = <span class="title function_">toRefs</span>(state)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      name,</span><br><span class="line">      age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h4><p>如果我们只希望转换一个reactive对象中的属性为ref,那么可以使用toRef的方法</p>
<p><strong>需要注意的是toRef的对象必须是reactive，否则无法建立链接，即返回值虽然是proxy但是不是响应式数据</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, toRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> age = <span class="title function_">toRef</span>(state)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      age</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="toRefs和toRef的区别"><a href="#toRefs和toRef的区别" class="headerlink" title="toRefs和toRef的区别"></a>toRefs和toRef的区别</h4><p>toRefs对reactive中的对象<strong>所有属性</strong>都转换成ref</p>
<p>toRef对reactive中的对象<strong>一个属性</strong>转换成ref</p>
<h4 id="ref其他api"><a href="#ref其他api" class="headerlink" title="ref其他api"></a>ref其他api</h4><ul>
<li>isRef<ul>
<li>判断值是否是一个ref对象</li>
</ul>
</li>
<li>unref<ul>
<li>如果我们想要获取一个ref引用中的value，那么也可以通过unref方法</li>
<li>如果参数是一个ref，则返回内部值，否则返回参数本身</li>
<li>这是<code>val= isRef(val) ? val.value: val</code>的语法糖函数</li>
</ul>
</li>
<li>shallowRef<ul>
<li>创建一个浅层的ref对象，即深层属性不会变成响应式</li>
</ul>
</li>
<li>triggerRef<ul>
<li>手动触发和shallowRef相关联的副作用</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ref, reactive, isRef, unref, shallowRef, triggerRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="title function_">ref</span>(<span class="number">12</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">addAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    age.<span class="property">value</span> += <span class="number">1</span> </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;isRef&#x27;</span>, <span class="title function_">isRef</span>(age)) <span class="comment">// true</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;unref&#x27;</span>, <span class="title function_">unref</span>(age)) <span class="comment">// 12</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;shallowRef&#x27;</span>, <span class="title function_">shallowRef</span>(<span class="number">12</span>)) <span class="comment">// shallowRef RefImpl</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> info = <span class="title function_">shallowRef</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    info.<span class="property">value</span>.<span class="property">name</span> = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    <span class="title function_">triggerRef</span>(info) <span class="comment">// 触发</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age,</span><br><span class="line">    addAge,</span><br><span class="line"></span><br><span class="line">    info,</span><br><span class="line">    changeName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h3><p>在我们传递给其他组件数据时，往往希望其他组件使用我们传递的内容，但是不允许它们修改时，就可以使用readonly了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive, readonly &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params">props, context</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">24</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> readonlyState = <span class="title function_">readonly</span>(state)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">addAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      readonlyState.<span class="property">age</span> += <span class="number">1</span> <span class="comment">// 报错Set operation on key &quot;age&quot; failed: target is readonly</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      state,</span><br><span class="line">      addAge,</span><br><span class="line">      readonlyState</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="readonly其他Api"><a href="#readonly其他Api" class="headerlink" title="readonly其他Api"></a>readonly其他Api</h4><ul>
<li>isReadonly<ul>
<li>检查对象是否是由readonly创建的只读代理</li>
</ul>
</li>
<li>shallowReadonly<ul>
<li>创建一个proxy，使其自身的property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）</li>
</ul>
</li>
</ul>
<h3 id="customRef"><a href="#customRef" class="headerlink" title="customRef"></a>customRef</h3><p>创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制</p>
<ul>
<li>它需要一个工厂函数，该函数接受track 和trigger函数作为参数</li>
<li>并且应该返回一个带有get 和set 的对象</li>
</ul>
<p>下面是防抖为例子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; customRef &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">useDeb</span>(<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">customRef</span>(<span class="function">(<span class="params">track, trigger</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">track</span>() <span class="comment">// 搜集依赖</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="comment">// 简单防抖</span></span><br><span class="line">        <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">        timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          value = newValue</span><br><span class="line">          <span class="title function_">trigger</span>() <span class="comment">// 触发</span></span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> message = <span class="title function_">useDeb</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    message</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>当我们的某些属性是依赖其他状态时，我们可以使用计算属性来处理</p>
<p>在Composition API中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性</p>
<p>computed的写法</p>
<ul>
<li>接收一个getter函数，并为 getter 函数返回的值，返回一个不变的** ref 对象**</li>
<li>接收一个具有 get 和 set 的对象，返回一个可变的（可读写）** ref 对象**</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;computed&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;fullName&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名称&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line"></span><br><span class="line">    const firstName = ref(&#x27;三&#x27;)</span><br><span class="line">    const lastName = ref(&#x27;张&#x27;)</span><br><span class="line"></span><br><span class="line">    const fullName = computed(() =&gt; &#123;</span><br><span class="line">      return firstName.value + &#x27; &#x27; + lastName.value</span><br><span class="line">    &#125;)</span><br><span class="line">    const fullName2 = computed(&#123;</span><br><span class="line">      get() &#123;</span><br><span class="line">        return firstName.value + &#x27; &#x27; + lastName.value</span><br><span class="line">      &#125;,</span><br><span class="line">      set(newValue) &#123;</span><br><span class="line">        const names = newValue.split(&#x27; &#x27;)</span><br><span class="line">        firstName.value = names[0]</span><br><span class="line">        lastName.value = names[1]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    const changeName = () =&gt; &#123;</span><br><span class="line">      fullName2.value = &#x27;四 李&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      fullName,</span><br><span class="line">      fullName2,</span><br><span class="line">      changeName</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="watchEffect和watch"><a href="#watchEffect和watch" class="headerlink" title="watchEffect和watch"></a>watchEffect和watch</h2><p>在Composition API中，我们可以使用watchEffect和watch来完成响应式数据的侦听</p>
<ul>
<li>watchEffect用于自动收集响应式数据的依赖</li>
<li>watch需要手动指定侦听的数据源</li>
</ul>
<h2 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h2><h3 id="watchEffect基本使用"><a href="#watchEffect基本使用" class="headerlink" title="watchEffect基本使用"></a>watchEffect基本使用</h3><p>当侦听到某些响应式数据变化时，我们希望执行某些操作，这个时候可以使用 watchEffect</p>
<ul>
<li>watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖</li>
<li>只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行(和computed一样是惰性的)</li>
</ul>
<p>如果在发生某些情况下，我们希望停止侦听，这个时候我们可以<strong>获取watchEffect的返回值函数</strong>，调用该函数即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;watch&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123;name&#125;&#125; - &#123;&#123;age&#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;changeName&quot;&gt;修改名称&lt;/button&gt;</span><br><span class="line">    &lt;button @click=&quot;changeAge&quot;&gt;修改年龄&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">    const name = ref(&#x27;张三&#x27;)</span><br><span class="line">    const age = ref(18)</span><br><span class="line"></span><br><span class="line">    const changeName = () =&gt; &#123;</span><br><span class="line">      name.value = &#x27;李四&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">    const watchEffectHandler = watchEffect(() =&gt; &#123;</span><br><span class="line">      console.log(&#x27;watchEffect&#x27;, name.value, age.value)</span><br><span class="line">    &#125;)</span><br><span class="line">    const changeAge = () =&gt; &#123;</span><br><span class="line">      age.value += 1</span><br><span class="line">      if (age.value &gt;= 30) &#123;</span><br><span class="line">        watchEffectHandler() // 停止侦听</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      name,</span><br><span class="line">      age,</span><br><span class="line">      changeName,</span><br><span class="line">      changeAge</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;</span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h3 id="watchEffect清除副作用"><a href="#watchEffect清除副作用" class="headerlink" title="watchEffect清除副作用"></a>watchEffect清除副作用</h3><p>比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器，或者侦听器侦听函数被再次执行了</p>
<p>那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用</p>
<p>在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数：onInvalidate</p>
<ul>
<li>当<strong>副作用即将重新执行</strong>或者<strong>侦听器被停止</strong>时会执行该函数传入的回调函数</li>
<li>我们可以在传入的回调函数中，执行一些清楚工作</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> watchEffectHandler = <span class="title function_">watchEffect</span>(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffectHandler&#x27;</span>, name.<span class="property">value</span>, age.<span class="property">value</span>)</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2s后&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">  <span class="title function_">onInvalidate</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="watchEffect执行时机"><a href="#watchEffect执行时机" class="headerlink" title="watchEffect执行时机"></a>watchEffect执行时机</h3><p>默认情况下，组件的更新会在副作用函数执行之前<br>这可能会导致一些问题，比如如果我们把ref放在watchEffect中时，由于上述原因，第一次会获取不到值</p>
<p>watchEffect中第二个参数为的配置项，其中flush可以控制执行时机</p>
<ul>
<li>pre: 默认值，它会在元素 挂载 或者 更新 之前执行</li>
<li>post: 首次渲染完成后执行</li>
<li>sync: 强制效果始终同步触发，但是这会很消耗性能，不推荐</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 ref=&quot;elRef&quot;&gt;elRef&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">    const elRef = ref(null)</span><br><span class="line">    watchEffect(() =&gt; &#123;</span><br><span class="line">      console.log(elRef.value)</span><br><span class="line">    &#125;, &#123; flush: &#x27;post&#x27; &#125;)</span><br><span class="line">    return &#123;</span><br><span class="line">        elRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>watch的API完全等同于组件watch选项的Property</p>
<ul>
<li>watch需要侦听特定的数据源，并在回调函数中执行副作用</li>
<li>默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调</li>
</ul>
<p>与watchEffect的比较，watch允许我们</p>
<ul>
<li>懒执行副作用（第一次不会直接执行）</li>
<li>更具体的说明当哪些状态发生变化时，触发侦听器的执行</li>
<li>访问侦听状态变化前后的值（需要注意的是，变化前后的值只对简单类型生效）</li>
</ul>
<h3 id="侦听单个数据源"><a href="#侦听单个数据源" class="headerlink" title="侦听单个数据源"></a>侦听单个数据源</h3><p>侦听器数据源可以是返回值的 getter 函数，也可以直接是ref</p>
<p>如果对reactive中某个属性进行监听时</p>
<ul>
<li>应以<code>() =&gt; value</code>形式传入，vue会自动帮你设置deep(深度监听)，<strong>仅在传入对象为reactive时才会自动设置</strong></li>
<li><strong>此时返回值为reactive对象</strong>，如果我们需要返回值为普通对象的话，可以以<code>() =&gt; (&#123;...obj&#125;)</code>形式传入</li>
</ul>
<p>如果对ref进行监听，返回值会<strong>以值的形式返回</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">13</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">() =&gt;</span> info.<span class="property">name</span>, <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="侦听多个数据源"><a href="#侦听多个数据源" class="headerlink" title="侦听多个数据源"></a>侦听多个数据源</h3><p>以数组形式传入即可监听多个数据源，内部实际上就是对数组进行遍历</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">13</span> &#125;)</span><br><span class="line"><span class="title function_">watch</span>([info, <span class="function">() =&gt;</span> info.<span class="property">name</span>], <span class="function">(<span class="params">newValue, oldValue</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(newValue, oldValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="watch的选项"><a href="#watch的选项" class="headerlink" title="watch的选项"></a>watch的选项</h3><p>deep：深度监听<br>immediate：立即执行</p>
<h2 id="setup中的ref"><a href="#setup中的ref" class="headerlink" title="setup中的ref"></a>setup中的ref</h2><p>定义一个ref对象，绑定到元素或者组件的ref属性上即可</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1 ref=&quot;elRef&quot;&gt;elRef&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line"></span><br><span class="line">  setup() &#123;</span><br><span class="line">    const elRef = ref(null)</span><br><span class="line">    return &#123;</span><br><span class="line">        elRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>beforeCreate和created的内容可以直接在setup中编写</p>
<table>
<thead>
<tr>
<th>options api</th>
<th>composition api</th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td>not needed</td>
</tr>
<tr>
<td>created</td>
<td>not needed</td>
</tr>
<tr>
<td>beforeMounte</td>
<td>onBeforeMounte</td>
</tr>
<tr>
<td>mounted</td>
<td>onMounted</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>onBeforeUpdate</td>
</tr>
<tr>
<td>updated</td>
<td>onUpdated</td>
</tr>
<tr>
<td>beforeUnmount</td>
<td>onBeforeUnmount</td>
</tr>
<tr>
<td>unmounted</td>
<td>onUnmounted</td>
</tr>
<tr>
<td>activated</td>
<td>onActivated</td>
</tr>
<tr>
<td>deactivated</td>
<td>onDeactivated</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onBeforeMount, onMounted, onBeforeUpdate ,onUpdated, onBeforeUnmount ,onUnmounted, ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">onBeforeMount</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeMount&#x27;</span>))</span><br><span class="line">    <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onMounted&#x27;</span>))</span><br><span class="line">    <span class="title function_">onBeforeUpdate</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeUpdate&#x27;</span>))</span><br><span class="line">    <span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onUpdated&#x27;</span>))</span><br><span class="line">    <span class="title function_">onBeforeUnmount</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onBeforeUnmount&#x27;</span>))</span><br><span class="line">    <span class="title function_">onUnmounted</span>(<span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;onUnmounted&#x27;</span>))</span><br><span class="line">    <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">addCount</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      count.<span class="property">value</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      addCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Provide-Inject"><a href="#Provide-Inject" class="headerlink" title="Provide/Inject"></a>Provide/Inject</h2><p>和options api使用方法基本一致</p>
<p>可以通过readonly包裹provide，实现单向数据流</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 祖先组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; provide, reactive, readonly&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="title function_">reactive</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> , <span class="attr">age</span>: <span class="number">12</span> &#125;)</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">changeAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      info.<span class="property">age</span> += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;info&#x27;</span>, <span class="title function_">readonly</span>(info)) <span class="comment">// 禁止后代修改 单向数据流</span></span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;changeAge&#x27;</span>, changeAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后代组件</span></span><br><span class="line"><span class="keyword">import</span> &#123; inject &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="title function_">inject</span>(<span class="string">&#x27;info&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> changeAge = <span class="title function_">inject</span>(<span class="string">&#x27;changeAge&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      info, changeAge</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>Vue推荐在绝大数情况下使用模板来创建你的HTML，然后一些特殊的场景，你真的需要JavaScript的完全编程的能力，这个时候你可以使用 渲染函数 ，它比模板更接近编译器</p>
<p>Vue在生成真实的DOM之前，会将我们的节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚 拟DOM（VDOM）</p>
<p>事实上，我们之前编写的 template 中的HTML 最终也是使用渲染函数生成对应的VNode</p>
<p>那么，如果你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的VNode</p>
<h3 id="h函数"><a href="#h函数" class="headerlink" title="h函数"></a>h函数</h3><p>h() 函数是一个用于创建 vnode 的一个函数，其实更准备的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数</p>
<h1 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h1><p>在Vue的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model等等，除了使用这些指令之外，Vue也允许我们来自定义自己的指令。</p>
<ul>
<li>注意：在Vue中，代码的复用和抽象主要还是通过组件</li>
<li>通常在某些情况下，你需要对DOM元素进行底层操作，这个时候就会用到自定义指令</li>
</ul>
<p>自定义指令分为两种</p>
<ul>
<li>自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用</li>
<li>自定义全局指令：app的 directive 方法，可以在任意组件中被使用</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当某个元素挂载完成后可以自定获取焦点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部指令</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">directives</span>: &#123;</span><br><span class="line">    <span class="attr">focus</span>: &#123;</span><br><span class="line">      <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">        el.<span class="title function_">focus</span>()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册</span></span><br><span class="line">app.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params">el</span>) &#123;</span><br><span class="line">    el.<span class="title function_">focus</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="指令生命周期"><a href="#指令生命周期" class="headerlink" title="指令生命周期"></a>指令生命周期</h2><p>一个指令定义的对象，Vue提供了如下的几个钩子函数</p>
<ul>
<li>created：在绑定元素的 attribute 或事件监听器被应用之前调用</li>
<li>beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用</li>
<li>mounted：在绑定元素的父组件被挂载后调用</li>
<li>beforeUpdate：在更新包含组件的 VNode 之前调用</li>
<li>updated：在包含组件的 VNode <strong>及其子组件的 VNode 更新后</strong>调用</li>
<li>beforeUnmount：在卸载绑定元素的父组件之前调用</li>
<li>unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次</li>
</ul>
<p>与vue对比</p>
<table>
<thead>
<tr>
<th>vue2中的指令生命周期</th>
<th>vue3中的指令生命周期</th>
</tr>
</thead>
<tbody><tr>
<td>无</td>
<td>created</td>
</tr>
<tr>
<td>bind</td>
<td>beforeMount</td>
</tr>
<tr>
<td>inserted</td>
<td>mounted</td>
</tr>
<tr>
<td>无</td>
<td>beforeUpdate</td>
</tr>
<tr>
<td>update</td>
<td>移除，该钩子与 <code>updated</code> 有太多相似之处，因此它是多余的。请改用 <code>updated</code></td>
</tr>
<tr>
<td>componentUpdated</td>
<td>updated</td>
</tr>
<tr>
<td>无</td>
<td>beforeUnmount</td>
</tr>
<tr>
<td>unbind</td>
<td>unmounted</td>
</tr>
</tbody></table>
<h2 id="指令回调参数"><a href="#指令回调参数" class="headerlink" title="指令回调参数"></a>指令回调参数</h2><p>每个生命周期都会返回4个参数回来</p>
<ul>
<li>el：指令挂载dom元素</li>
<li>bindings：使用指令时的传参<ul>
<li>arg：参数的名称</li>
<li>modifiers：修饰符</li>
<li>value：传参</li>
<li>instance：虚拟dom</li>
<li>dir：指令的配置项</li>
</ul>
</li>
<li>vNode：挂载对象的vNode</li>
<li>preVnode：挂载对象的父级vNode</li>
</ul>
<p>如现在使用<code>v-focus:info.aaa.bbb=&quot;&#123;name: &#39;张三&#39;, age: 18&#125;&quot;</code>, 则bindings返回值如下（以下不给出虚拟相关）</p>
<ul>
<li>arg: ‘info</li>
<li>value: {name: ‘张三’, age: 18}</li>
<li>modifiers: {aaa: true, bbb: true}’</li>
</ul>
<h1 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h1><p>在组件化开发中，我们封装一个组件A，在另外一个组件B中使用</p>
<ul>
<li>那么组件A中template的元素，会被挂载到组件B中template的某个位置</li>
<li>最终我们的应用程序会形成一颗DOM树结构</li>
</ul>
<p>但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置</p>
<ul>
<li>比如移动到body元素上，或者我们有其他的div#app之外的元素上</li>
<li>这个时候我们就可以通过teleport来完成</li>
</ul>
<p>Teleport是一个Vue提供的内置组件，类似于react的Portals，它有两个属性</p>
<ul>
<li>to：指定将其中的内容移动到的目标元素，可以使用选择器</li>
<li>disabled：是否禁用 teleport 的功能</li>
</ul>
<p>如果我们将多个teleport应用到同一个目标上（to的值相同），那么这些目标会进行合并</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;teleport to=&quot;#app2&quot;&gt;</span><br><span class="line">    &lt;h2&gt;当前计数&lt;/h2&gt;</span><br><span class="line">    &lt;button&gt;+1&lt;/button&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure>

<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式</p>
<ul>
<li>对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行</li>
<li>函数类型：一个function，这个函数会在安装插件时自动执行</li>
</ul>
<p>插件可以完成的功能没有限制，比如下面的几种都是可以的</p>
<ul>
<li>添加全局方法或者 property，通过把它们添加到 config.globalProperties 上实现</li>
<li>添加全局资源：指令/过滤器/过渡等</li>
<li>通过全局 mixin 来添加一些组件选项</li>
<li>一个库，提供自己的 API，同时提供上面提到的一个或多个功能</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/composition-api/" data-id="cldjpozun000198t4gj4g4axt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gradle全局镜像" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/31/gradle%E5%85%A8%E5%B1%80%E9%95%9C%E5%83%8F/" class="article-date">
  <time datetime="2023-01-31T03:17:53.000Z" itemprop="datePublished">2023-01-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/31/gradle%E5%85%A8%E5%B1%80%E9%95%9C%E5%83%8F/">gradle全局镜像</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h1><p>在<code>C:\Users\用户名\.gradle</code>下创建<code>init.gradle</code></p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">settingsEvaluated &#123; settings -&gt;</span><br><span class="line">    settings.dependencyResolutionManagement &#123;</span><br><span class="line">        <span class="keyword">repositories</span> &#123;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            google &#123;</span><br><span class="line">                url <span class="string">&quot;https://maven.aliyun.com/repository/google&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        maven &#123;</span><br><span class="line">            url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        google &#123;</span><br><span class="line">            url <span class="string">&quot;https://maven.aliyun.com/repository/google&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">buildscript</span> &#123;</span><br><span class="line">        <span class="keyword">repositories</span> &#123;</span><br><span class="line">            maven &#123;</span><br><span class="line">                url <span class="string">&quot;https://maven.aliyun.com/repository/public&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">            google &#123;</span><br><span class="line">                url <span class="string">&quot;https://maven.aliyun.com/repository/google&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/31/gradle%E5%85%A8%E5%B1%80%E9%95%9C%E5%83%8F/" data-id="cldjpozuq000498t41lxg4ird" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/element-ui/" rel="tag">element-ui</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/" rel="tag">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm/" rel="tag">npm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/router/" rel="tag">router</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue3/" rel="tag">vue3</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/" rel="tag">模块化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" rel="tag">浏览器</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%BA%90%E7%A0%81/" rel="tag">源码</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%85%8D%E7%BD%AE/" rel="tag">配置</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/element-ui/" style="font-size: 10px;">element-ui</a> <a href="/tags/javascript/" style="font-size: 20px;">javascript</a> <a href="/tags/npm/" style="font-size: 10px;">npm</a> <a href="/tags/router/" style="font-size: 10px;">router</a> <a href="/tags/vue/" style="font-size: 17.5px;">vue</a> <a href="/tags/vue3/" style="font-size: 10px;">vue3</a> <a href="/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/" style="font-size: 10px;">模块化</a> <a href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/" style="font-size: 12.5px;">浏览器</a> <a href="/tags/%E6%BA%90%E7%A0%81/" style="font-size: 15px;">源码</a> <a href="/tags/%E9%85%8D%E7%BD%AE/" style="font-size: 10px;">配置</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/01/31/js%E4%B8%AD%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E7%AC%A6%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%8A%B6%E6%80%81/">js中属性描述符与对象状态</a>
          </li>
        
          <li>
            <a href="/2023/01/31/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/">事件循环</a>
          </li>
        
          <li>
            <a href="/2023/01/31/js%E4%B8%AD%E7%9A%84%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/">js中的浅拷贝与深拷贝</a>
          </li>
        
          <li>
            <a href="/2023/01/31/%E9%89%B4%E6%9D%83%E5%92%8C%E5%9C%A8node%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0/">鉴权和在node上的实现</a>
          </li>
        
          <li>
            <a href="/2023/01/31/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%88GC%EF%BC%89/">垃圾回收机制（GC）</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2023 月夜静翼<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>